// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null)  {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.indexOf('@') === 0 ? path.split('/', 2).join("/") : path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		var localRequire = function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
		if (envRequire) localRequire.fromParentEnvironment = envRequire;
		return localRequire
	};
	return getRequire(modules, [], '');
})
({
	"bowser": {
		":mainpath:": "./src/bowser.js",
		"src": {
			"bowser.js": function (exports, module, require) {
				

				/*!
				 * Bowser - a browser detector
				 * https://github.com/ded/bowser
				 * MIT License | (c) Dustin Diaz 2015
				 */
				!function (root, name, definition) {
				  if (typeof module != 'undefined' && module.exports) module.exports = definition();else if (typeof define == 'function' && define.amd) define(name, definition);else root[name] = definition();
				}(void 0, 'bowser', function () {
				  /**
				    * See useragents.js for examples of navigator.userAgent
				    */
				  var t = true;

				  function detect(ua) {
				    function getFirstMatch(regex) {
				      var match = ua.match(regex);
				      return match && match.length > 1 && match[1] || '';
				    }

				    function getSecondMatch(regex) {
				      var match = ua.match(regex);
				      return match && match.length > 1 && match[2] || '';
				    }

				    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),
				        likeAndroid = /like android/i.test(ua),
				        android = !likeAndroid && /android/i.test(ua),
				        nexusMobile = /nexus\s*[0-6]\s*/i.test(ua),
				        nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua),
				        chromeos = /CrOS/.test(ua),
				        silk = /silk/i.test(ua),
				        sailfish = /sailfish/i.test(ua),
				        tizen = /tizen/i.test(ua),
				        webos = /(web|hpw)os/i.test(ua),
				        windowsphone = /windows phone/i.test(ua),
				        samsungBrowser = /SamsungBrowser/i.test(ua),
				        windows = !windowsphone && /windows/i.test(ua),
				        mac = !iosdevice && !silk && /macintosh/i.test(ua),
				        linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua),
				        edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i),
				        versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i),
				        tablet = /tablet/i.test(ua),
				        mobile = !tablet && /[^-]mobi/i.test(ua),
				        xbox = /xbox/i.test(ua),
				        result;

				    if (/opera/i.test(ua)) {
				      //  an old Opera
				      result = {
				        name: 'Opera',
				        opera: t,
				        version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/opr|opios/i.test(ua)) {
				      // a new Opera
				      result = {
				        name: 'Opera',
				        opera: t,
				        version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (/SamsungBrowser/i.test(ua)) {
				      result = {
				        name: 'Samsung Internet for Android',
				        samsungBrowser: t,
				        version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/coast/i.test(ua)) {
				      result = {
				        name: 'Opera Coast',
				        coast: t,
				        version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/yabrowser/i.test(ua)) {
				      result = {
				        name: 'Yandex Browser',
				        yandexbrowser: t,
				        version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
				      };
				    } else if (/ucbrowser/i.test(ua)) {
				      result = {
				        name: 'UC Browser',
				        ucbrowser: t,
				        version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/mxios/i.test(ua)) {
				      result = {
				        name: 'Maxthon',
				        maxthon: t,
				        version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/epiphany/i.test(ua)) {
				      result = {
				        name: 'Epiphany',
				        epiphany: t,
				        version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/puffin/i.test(ua)) {
				      result = {
				        name: 'Puffin',
				        puffin: t,
				        version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
				      };
				    } else if (/sleipnir/i.test(ua)) {
				      result = {
				        name: 'Sleipnir',
				        sleipnir: t,
				        version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (/k-meleon/i.test(ua)) {
				      result = {
				        name: 'K-Meleon',
				        kMeleon: t,
				        version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
				      };
				    } else if (windowsphone) {
				      result = {
				        name: 'Windows Phone',
				        windowsphone: t
				      };

				      if (edgeVersion) {
				        result.msedge = t;
				        result.version = edgeVersion;
				      } else {
				        result.msie = t;
				        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
				      }
				    } else if (/msie|trident/i.test(ua)) {
				      result = {
				        name: 'Internet Explorer',
				        msie: t,
				        version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
				      };
				    } else if (chromeos) {
				      result = {
				        name: 'Chrome',
				        chromeos: t,
				        chromeBook: t,
				        chrome: t,
				        version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/chrome.+? edge/i.test(ua)) {
				      result = {
				        name: 'Microsoft Edge',
				        msedge: t,
				        version: edgeVersion
				      };
				    } else if (/vivaldi/i.test(ua)) {
				      result = {
				        name: 'Vivaldi',
				        vivaldi: t,
				        version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (sailfish) {
				      result = {
				        name: 'Sailfish',
				        sailfish: t,
				        version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/seamonkey\//i.test(ua)) {
				      result = {
				        name: 'SeaMonkey',
				        seamonkey: t,
				        version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/firefox|iceweasel|fxios/i.test(ua)) {
				      result = {
				        name: 'Firefox',
				        firefox: t,
				        version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
				      };

				      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
				        result.firefoxos = t;
				      }
				    } else if (silk) {
				      result = {
				        name: 'Amazon Silk',
				        silk: t,
				        version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/phantom/i.test(ua)) {
				      result = {
				        name: 'PhantomJS',
				        phantom: t,
				        version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/slimerjs/i.test(ua)) {
				      result = {
				        name: 'SlimerJS',
				        slimer: t,
				        version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
				      };
				    } else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
				      result = {
				        name: 'BlackBerry',
				        blackberry: t,
				        version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
				      };
				    } else if (webos) {
				      result = {
				        name: 'WebOS',
				        webos: t,
				        version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
				      };
				      /touchpad\//i.test(ua) && (result.touchpad = t);
				    } else if (/bada/i.test(ua)) {
				      result = {
				        name: 'Bada',
				        bada: t,
				        version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
				      };
				    } else if (tizen) {
				      result = {
				        name: 'Tizen',
				        tizen: t,
				        version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (/qupzilla/i.test(ua)) {
				      result = {
				        name: 'QupZilla',
				        qupzilla: t,
				        version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
				      };
				    } else if (/chromium/i.test(ua)) {
				      result = {
				        name: 'Chromium',
				        chromium: t,
				        version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
				      };
				    } else if (/chrome|crios|crmo/i.test(ua)) {
				      result = {
				        name: 'Chrome',
				        chrome: t,
				        version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
				      };
				    } else if (android) {
				      result = {
				        name: 'Android',
				        version: versionIdentifier
				      };
				    } else if (/safari|applewebkit/i.test(ua)) {
				      result = {
				        name: 'Safari',
				        safari: t
				      };

				      if (versionIdentifier) {
				        result.version = versionIdentifier;
				      }
				    } else if (iosdevice) {
				      result = {
				        name: iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
				      }; // WTF: version is not part of user agent in web apps

				      if (versionIdentifier) {
				        result.version = versionIdentifier;
				      }
				    } else if (/googlebot/i.test(ua)) {
				      result = {
				        name: 'Googlebot',
				        googlebot: t,
				        version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
				      };
				    } else {
				      result = {
				        name: getFirstMatch(/^(.*)\/(.*) /),
				        version: getSecondMatch(/^(.*)\/(.*) /)
				      };
				    } // set webkit or gecko flag for browsers based on these engines


				    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
				      if (/(apple)?webkit\/537\.36/i.test(ua)) {
				        result.name = result.name || "Blink";
				        result.blink = t;
				      } else {
				        result.name = result.name || "Webkit";
				        result.webkit = t;
				      }

				      if (!result.version && versionIdentifier) {
				        result.version = versionIdentifier;
				      }
				    } else if (!result.opera && /gecko\//i.test(ua)) {
				      result.name = result.name || "Gecko";
				      result.gecko = t;
				      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
				    } // set OS flags for platforms that have multiple browsers


				    if (!result.windowsphone && !result.msedge && (android || result.silk)) {
				      result.android = t;
				    } else if (!result.windowsphone && !result.msedge && iosdevice) {
				      result[iosdevice] = t;
				      result.ios = t;
				    } else if (mac) {
				      result.mac = t;
				    } else if (xbox) {
				      result.xbox = t;
				    } else if (windows) {
				      result.windows = t;
				    } else if (linux) {
				      result.linux = t;
				    } // OS version extraction


				    var osVersion = '';

				    if (result.windowsphone) {
				      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
				    } else if (iosdevice) {
				      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
				      osVersion = osVersion.replace(/[_\s]/g, '.');
				    } else if (android) {
				      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
				    } else if (result.webos) {
				      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
				    } else if (result.blackberry) {
				      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
				    } else if (result.bada) {
				      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
				    } else if (result.tizen) {
				      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
				    }

				    if (osVersion) {
				      result.osversion = osVersion;
				    } // device type extraction


				    var osMajorVersion = osVersion.split('.')[0];

				    if (tablet || nexusTablet || iosdevice == 'ipad' || android && (osMajorVersion == 3 || osMajorVersion >= 4 && !mobile) || result.silk) {
				      result.tablet = t;
				    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || nexusMobile || result.blackberry || result.webos || result.bada) {
				      result.mobile = t;
				    } // Graded Browser Support
				    // http://developer.yahoo.com/yui/articles/gbs


				    if (result.msedge || result.msie && result.version >= 10 || result.yandexbrowser && result.version >= 15 || result.vivaldi && result.version >= 1.0 || result.chrome && result.version >= 20 || result.samsungBrowser && result.version >= 4 || result.firefox && result.version >= 20.0 || result.safari && result.version >= 6 || result.opera && result.version >= 10.0 || result.ios && result.osversion && result.osversion.split(".")[0] >= 6 || result.blackberry && result.version >= 10.1 || result.chromium && result.version >= 20) {
				      result.a = t;
				    } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20.0 || result.safari && result.version < 6 || result.opera && result.version < 10.0 || result.ios && result.osversion && result.osversion.split(".")[0] < 6 || result.chromium && result.version < 20) {
				      result.c = t;
				    } else result.x = t;

				    return result;
				  }

				  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '');

				  bowser.test = function (browserList) {
				    for (var i = 0; i < browserList.length; ++i) {
				      var browserItem = browserList[i];

				      if (typeof browserItem === 'string') {
				        if (browserItem in bowser) {
				          return true;
				        }
				      }
				    }

				    return false;
				  };
				  /**
				   * Get version precisions count
				   *
				   * @example
				   *   getVersionPrecision("1.10.3") // 3
				   *
				   * @param  {string} version
				   * @return {number}
				   */


				  function getVersionPrecision(version) {
				    return version.split(".").length;
				  }
				  /**
				   * Array::map polyfill
				   *
				   * @param  {Array} arr
				   * @param  {Function} iterator
				   * @return {Array}
				   */


				  function map(arr, iterator) {
				    var result = [],
				        i;

				    if (Array.prototype.map) {
				      return Array.prototype.map.call(arr, iterator);
				    }

				    for (i = 0; i < arr.length; i++) {
				      result.push(iterator(arr[i]));
				    }

				    return result;
				  }
				  /**
				   * Calculate browser version weight
				   *
				   * @example
				   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
				   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
				   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
				   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
				   *
				   * @param  {Array<String>} versions versions to compare
				   * @return {Number} comparison result
				   */


				  function compareVersions(versions) {
				    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
				    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
				    var chunks = map(versions, function (version) {
				      var delta = precision - getVersionPrecision(version); // 2) "9" -> "9.0" (for precision = 2)

				      version = version + new Array(delta + 1).join(".0"); // 3) "9.0" -> ["000000000"", "000000009"]

				      return map(version.split("."), function (chunk) {
				        return new Array(20 - chunk.length).join("0") + chunk;
				      }).reverse();
				    }); // iterate in reverse order by reversed chunks array

				    while (--precision >= 0) {
				      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
				      if (chunks[0][precision] > chunks[1][precision]) {
				        return 1;
				      } else if (chunks[0][precision] === chunks[1][precision]) {
				        if (precision === 0) {
				          // all version chunks are same
				          return 0;
				        }
				      } else {
				        return -1;
				      }
				    }
				  }
				  /**
				   * Check if browser is unsupported
				   *
				   * @example
				   *   bowser.isUnsupportedBrowser({
				   *     msie: "10",
				   *     firefox: "23",
				   *     chrome: "29",
				   *     safari: "5.1",
				   *     opera: "16",
				   *     phantom: "534"
				   *   });
				   *
				   * @param  {Object}  minVersions map of minimal version to browser
				   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
				   * @param  {String}  [ua] user agent string
				   * @return {Boolean}
				   */


				  function isUnsupportedBrowser(minVersions, strictMode, ua) {
				    var _bowser = bowser; // make strictMode param optional with ua param usage

				    if (typeof strictMode === 'string') {
				      ua = strictMode;
				      strictMode = void 0;
				    }

				    if (strictMode === void 0) {
				      strictMode = false;
				    }

				    if (ua) {
				      _bowser = detect(ua);
				    }

				    var version = "" + _bowser.version;

				    for (var browser in minVersions) {
				      if (minVersions.hasOwnProperty(browser)) {
				        if (_bowser[browser]) {
				          if (typeof minVersions[browser] !== 'string') {
				            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
				          } // browser version and min supported version.


				          return compareVersions([version, minVersions[browser]]) < 0;
				        }
				      }
				    }

				    return strictMode; // not found
				  }
				  /**
				   * Check if browser is supported
				   *
				   * @param  {Object} minVersions map of minimal version to browser
				   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
				   * @param  {String}  [ua] user agent string
				   * @return {Boolean}
				   */


				  function check(minVersions, strictMode, ua) {
				    return !isUnsupportedBrowser(minVersions, strictMode, ua);
				  }

				  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
				  bowser.compareVersions = compareVersions;
				  bowser.check = check;
				  /*
				   * Set our detect method to the main bowser object so we can
				   * reuse it to test other user agents.
				   * This is needed to implement future tests.
				   */

				  bowser._detect = detect;
				  return bowser;
				});
			}
		}
	},
	"testcafe-hammerhead": {
		"src": {
			"client": {
				"sandbox": {
					"base.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;

						var _eventEmitter = _interopRequireDefault(require("../utils/event-emitter"));

						var _nativeMethods = _interopRequireDefault(require("./native-methods"));

						var _dom = require("../utils/dom");

						var _internalProperties = _interopRequireDefault(require("../../processing/dom/internal-properties"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

						var SandboxBase = /*#__PURE__*/function (_EventEmitter) {
						  _inheritsLoose(SandboxBase, _EventEmitter);

						  function SandboxBase() {
						    var _this;

						    _this = _EventEmitter.apply(this, arguments) || this;
						    _this.window = null;
						    _this.nativeMethods = _nativeMethods.default;
						    _this.document = null;
						    return _this;
						  } // NOTE: The sandbox is deactivated when its window is removed from the DOM.


						  var _proto = SandboxBase.prototype;

						  _proto.isDeactivated = function isDeactivated() {
						    try {
						      // NOTE: In IE11, a situation when the document is not active may occur.
						      // eslint-disable-next-line no-unused-expressions
						      this.document.body;

						      if (this.window[_internalProperties.default.hammerhead]) {
						        var frameElement = (0, _dom.getFrameElement)(this.window);
						        return !!frameElement && !(0, _dom.isElementInDocument)(frameElement, (0, _dom.findDocument)(frameElement));
						      }
						    } catch (e) {// eslint-disable-line no-empty
						    }

						    return true;
						  };

						  _proto.attach = function attach(window, document) {
						    this.window = window;
						    this.document = document || window.document;
						  };

						  return SandboxBase;
						}(_eventEmitter.default);

						exports.default = SandboxBase;
						module.exports = exports.default;
					},
					"fetch.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;

						var _base = _interopRequireDefault(require("./base"));

						var _nativeMethods = _interopRequireDefault(require("./native-methods"));

						var _internalHeaderNames = _interopRequireDefault(require("../../request-pipeline/internal-header-names"));

						var _builtinHeaderNames = _interopRequireDefault(require("../../request-pipeline/builtin-header-names"));

						var _url = require("../utils/url");

						var _destinationLocation = require("../utils/destination-location");

						var _dom = require("../utils/dom");

						var _sameOriginCheckFailedStatusCode = _interopRequireDefault(require("../../request-pipeline/xhr/same-origin-check-failed-status-code"));

						var _propertyOverriding = require("../utils/property-overriding");

						var browserUtils = _interopRequireWildcard(require("../utils/browser"));

						var _headers = require("../utils/headers");

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

						var DEFAULT_REQUEST_CREDENTIALS = _nativeMethods.default.Request ? new _nativeMethods.default.Request(location.toString()).credentials : void 0;

						var FetchSandbox = /*#__PURE__*/function (_SandboxBase) {
						  _inheritsLoose(FetchSandbox, _SandboxBase);

						  function FetchSandbox(cookieSandbox) {
						    var _this;

						    _this = _SandboxBase.call(this) || this;
						    _this.cookieSandbox = cookieSandbox;
						    _this.FETCH_REQUEST_SENT_EVENT = 'hammerhead|event|fetch-request-sent-event';
						    return _this;
						  }

						  FetchSandbox._addSpecialHeadersToRequestInit = function _addSpecialHeadersToRequestInit(init) {
						    var credentials = init.credentials || DEFAULT_REQUEST_CREDENTIALS;
						    var headers = init.headers;

						    if (!(0, _dom.isFetchHeaders)(headers)) {
						      // @ts-ignore
						      headers = headers ? new _nativeMethods.default.Headers(headers) : new _nativeMethods.default.Headers();
						      init.headers = headers;
						    } // eslint-disable-next-line no-restricted-properties


						    _nativeMethods.default.headersSet.call(headers, _internalHeaderNames.default.origin, (0, _destinationLocation.getOriginHeader)());

						    _nativeMethods.default.headersSet.call(headers, _internalHeaderNames.default.credentials, credentials);

						    var authorizationValue = _nativeMethods.default.headersGet.call(headers, _builtinHeaderNames.default.authorization);

						    var proxyAuthorizationValue = _nativeMethods.default.headersGet.call(headers, _builtinHeaderNames.default.proxyAuthorization);

						    if (authorizationValue !== null) {
						      _nativeMethods.default.headersSet.call(headers, _internalHeaderNames.default.authorization, authorizationValue);

						      _nativeMethods.default.headersDelete.call(headers, _builtinHeaderNames.default.authorization);
						    }

						    if (proxyAuthorizationValue !== null) {
						      _nativeMethods.default.headersSet.call(headers, _internalHeaderNames.default.proxyAuthorization, proxyAuthorizationValue);

						      _nativeMethods.default.headersDelete.call(headers, _builtinHeaderNames.default.proxyAuthorization);
						    }

						    return init;
						  };

						  FetchSandbox._processArguments = function _processArguments(args) {
						    var input = args[0],
						        init = args[1];
						    var inputIsString = typeof input === 'string';
						    var inputIsFetchRequest = (0, _dom.isFetchRequest)(input);

						    if (!inputIsFetchRequest) {
						      args[0] = (0, _url.getProxyUrl)(inputIsString ? input : String(input));
						      args[1] = FetchSandbox._addSpecialHeadersToRequestInit(init || {});
						    } else if (init && init.headers) args[1] = FetchSandbox._addSpecialHeadersToRequestInit(init);
						  };

						  FetchSandbox._sameOriginCheck = function _sameOriginCheck(_ref) {
						    var input = _ref[0],
						        init = _ref[1];
						    var url = null;
						    var requestMode = null;

						    if ((0, _dom.isFetchRequest)(input)) {
						      url = (0, _url.getDestinationUrl)(_nativeMethods.default.requestUrlGetter.call(input));
						      requestMode = input.mode;
						    } else {
						      url = (0, _url.getDestinationUrl)(input);
						      requestMode = init && init.mode;
						    }

						    if (requestMode === 'same-origin') return (0, _destinationLocation.sameOriginCheck)((0, _destinationLocation.get)(), url);
						    return true;
						  };

						  FetchSandbox._createAccessorWrapper = function _createAccessorWrapper(nativeFn) {
						    return function () {
						      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
						        args[_key] = arguments[_key];
						      }

						      args[0] = (0, _headers.transformHeaderNameToInternal)(args[0]);
						      return nativeFn.apply(this, args);
						    };
						  };

						  FetchSandbox._getResponseType = function _getResponseType(response) {
						    var destUrl = (0, _url.getDestinationUrl)(_nativeMethods.default.responseUrlGetter.call(response));
						    var isSameOrigin = (0, _destinationLocation.sameOriginCheck)((0, _destinationLocation.get)(), destUrl);
						    if (isSameOrigin) return 'basic';
						    return response.status === 0 ? 'opaque' : 'cors';
						  };

						  FetchSandbox._entriesFilteredNext = function _entriesFilteredNext(iterator, nativeNext) {
						    var entry = nativeNext.apply(iterator);
						    if (entry.done) return entry;
						    var headerName = entry.value[0]; // eslint-disable-line no-restricted-properties
						    // eslint-disable-next-line no-restricted-properties

						    if (headerName === _internalHeaderNames.default.origin || headerName === _internalHeaderNames.default.credentials) return FetchSandbox._entriesFilteredNext(iterator, nativeNext);
						    entry.value[0] = (0, _headers.transformHeaderNameToBuiltin)(headerName); // eslint-disable-line no-restricted-properties

						    return entry;
						  };

						  FetchSandbox._entriesWrapper = function _entriesWrapper() {
						    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						      args[_key2] = arguments[_key2];
						    }

						    var iterator = _nativeMethods.default.headersEntries.apply(this, args);

						    var nativeNext = iterator.next;

						    iterator.next = function () {
						      return FetchSandbox._entriesFilteredNext(iterator, nativeNext);
						    };

						    return iterator;
						  };

						  FetchSandbox._valuesWrapper = function _valuesWrapper() {
						    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
						      args[_key3] = arguments[_key3];
						    }

						    var iterator = _nativeMethods.default.headersEntries.apply(this, args);

						    var nativeNext = iterator.next;

						    iterator.next = function () {
						      var filteredEntry = FetchSandbox._entriesFilteredNext(iterator, nativeNext);

						      if (!filteredEntry.done) filteredEntry.value = filteredEntry.value[1]; // eslint-disable-line no-restricted-properties

						      return filteredEntry;
						    };

						    return iterator;
						  };

						  var _proto = FetchSandbox.prototype;

						  _proto.attach = function attach(window) {
						    _SandboxBase.prototype.attach.call(this, window, window.document);

						    if (!_nativeMethods.default.fetch) return;
						    var sandbox = this;

						    window.Request = function () {
						      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
						        args[_key4] = arguments[_key4];
						      }

						      FetchSandbox._processArguments(args);

						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = _nativeMethods.default.headersEntries;
						      var request = args.length === 1 ? new _nativeMethods.default.Request(args[0]) : new _nativeMethods.default.Request(args[0], args[1]);
						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = FetchSandbox._entriesWrapper;
						      return request;
						    };

						    window.Request.prototype = _nativeMethods.default.Request.prototype;
						    (0, _propertyOverriding.overrideDescriptor)(window.Request.prototype, 'url', {
						      getter: function getter() {
						        return (0, _url.getDestinationUrl)(_nativeMethods.default.requestUrlGetter.call(this));
						      }
						    });

						    window.fetch = function () {
						      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
						        args[_key5] = arguments[_key5];
						      }

						      // NOTE: Safari processed the empty `fetch()` request without `Promise` rejection (GH-1613)
						      if (!args.length && !browserUtils.isSafari) return _nativeMethods.default.fetch.apply(this);

						      try {
						        FetchSandbox._processArguments(args);
						      } catch (e) {
						        // @ts-ignore
						        return _nativeMethods.default.promiseReject.call(sandbox.window.Promise, e);
						      }

						      if (!FetchSandbox._sameOriginCheck(args)) // @ts-ignore
						        return _nativeMethods.default.promiseReject.call(sandbox.window.Promise, new TypeError());
						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = _nativeMethods.default.headersEntries;

						      var fetchPromise = _nativeMethods.default.fetch.apply(this, args);

						      window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = FetchSandbox._entriesWrapper;
						      sandbox.emit(sandbox.FETCH_REQUEST_SENT_EVENT, fetchPromise);
						      return _nativeMethods.default.promiseThen.call(fetchPromise, function (response) {
						        sandbox.cookieSandbox.syncCookie();
						        return response;
						      });
						    };

						    var fetchToString = _nativeMethods.default.fetch.toString();

						    window.fetch.toString = function () {
						      return fetchToString;
						    };

						    (0, _propertyOverriding.overrideDescriptor)(window.Response.prototype, 'type', {
						      getter: function getter() {
						        return FetchSandbox._getResponseType(this);
						      }
						    });
						    (0, _propertyOverriding.overrideDescriptor)(window.Response.prototype, 'status', {
						      getter: function getter() {
						        var responseStatus = _nativeMethods.default.responseStatusGetter.call(this);

						        return responseStatus === _sameOriginCheckFailedStatusCode.default ? 0 : responseStatus;
						      }
						    });
						    (0, _propertyOverriding.overrideDescriptor)(window.Response.prototype, 'url', {
						      getter: function getter() {
						        return (0, _url.getDestinationUrl)(_nativeMethods.default.responseUrlGetter.call(this));
						      }
						    });
						    window.Headers.prototype.entries = window.Headers.prototype[Symbol.iterator] = FetchSandbox._entriesWrapper;
						    window.Headers.prototype.values = FetchSandbox._valuesWrapper;

						    window.Headers.prototype.forEach = function () {
						      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
						        args[_key6] = arguments[_key6];
						      }

						      var callback = args[0];

						      if (typeof callback === 'function') {
						        args[0] = function (value, name, headers) {
						          // eslint-disable-next-line no-restricted-properties
						          if (name === _internalHeaderNames.default.origin || name === _internalHeaderNames.default.credentials) return;
						          name = (0, _headers.transformHeaderNameToBuiltin)(name);
						          callback.call(this, value, name, headers);
						        };
						      }

						      return _nativeMethods.default.headersForEach.apply(this, args);
						    };

						    window.Headers.prototype.get = FetchSandbox._createAccessorWrapper(_nativeMethods.default.headersGet);
						    window.Headers.prototype.set = FetchSandbox._createAccessorWrapper(_nativeMethods.default.headersSet);
						    window.Headers.prototype.has = FetchSandbox._createAccessorWrapper(_nativeMethods.default.headersHas);
						  };

						  return FetchSandbox;
						}(_base.default);

						exports.default = FetchSandbox;
						module.exports = exports.default;
					},
					"native-methods.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;

						var _globalContextInfo = _interopRequireDefault(require("../utils/global-context-info"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						/*global Document, Window */
						var NATIVE_CODE_RE = /\[native code]/;

						var NativeMethods = /*#__PURE__*/function () {
						  function NativeMethods(doc, win) {
						    var globalCtx = (0, _globalContextInfo.default)();
						    win = win || globalCtx.global;
						    this.refreshWindowMeths(win, globalCtx.isInWorker);
						    if (globalCtx.isInWorker) return;
						    this.refreshDocumentMeths(doc, win);
						    this.refreshElementMeths(doc, win);
						  }

						  NativeMethods._getDocumentPropOwnerName = function _getDocumentPropOwnerName(docPrototype, propName) {
						    return docPrototype.hasOwnProperty(propName) ? 'Document' : 'HTMLDocument';
						  };

						  var _proto = NativeMethods.prototype;

						  _proto.getStoragesPropsOwner = function getStoragesPropsOwner(win) {
						    return this.isStoragePropsLocatedInProto ? win.Window.prototype : win;
						  };

						  _proto.refreshDocumentMeths = function refreshDocumentMeths(doc, win) {
						    doc = doc || document;
						    win = win || window; // @ts-ignore

						    var docPrototype = win.Document.prototype; // Dom

						    this.createDocumentFragment = docPrototype.createDocumentFragment;
						    this.createElement = docPrototype.createElement;
						    this.createElementNS = docPrototype.createElementNS;
						    this.documentOpenPropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'open');
						    this.documentClosePropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'close');
						    this.documentWritePropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'write');
						    this.documentWriteLnPropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'writeln');
						    this.documentOpen = win[this.documentOpenPropOwnerName].prototype.open;
						    this.documentClose = win[this.documentClosePropOwnerName].prototype.close;
						    this.documentWrite = win[this.documentWritePropOwnerName].prototype.write;
						    this.documentWriteLn = win[this.documentWriteLnPropOwnerName].prototype.writeln;
						    this.elementFromPoint = docPrototype.elementFromPoint;
						    this.caretRangeFromPoint = docPrototype.caretRangeFromPoint;
						    this.caretPositionFromPoint = docPrototype.caretPositionFromPoint;
						    this.getElementById = docPrototype.getElementById;
						    this.getElementsByClassName = docPrototype.getElementsByClassName;
						    this.getElementsByName = docPrototype.getElementsByName;
						    this.getElementsByTagName = docPrototype.getElementsByTagName;
						    this.querySelector = docPrototype.querySelector;
						    this.querySelectorAll = docPrototype.querySelectorAll;
						    this.createHTMLDocument = win.DOMImplementation.prototype.createHTMLDocument; // @ts-ignore

						    if (doc.registerElement) {
						      // @ts-ignore
						      this.registerElement = docPrototype.registerElement;
						    } // Event
						    // NOTE: IE11 has no EventTarget so we should save "Event" methods separately


						    if (!win.EventTarget) {
						      this.documentAddEventListener = docPrototype.addEventListener;
						      this.documentRemoveEventListener = docPrototype.removeEventListener;
						    }

						    this.documentCreateEvent = docPrototype.createEvent;
						    this.documentCreateTouch = docPrototype.createTouch;
						    this.documentCreateTouchList = docPrototype.createTouchList; // getters/setters

						    this.documentCookiePropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'cookie');
						    this.documentScriptsPropOwnerName = NativeMethods._getDocumentPropOwnerName(docPrototype, 'scripts');
						    var documentCookieDescriptor = win.Object.getOwnPropertyDescriptor(win[this.documentCookiePropOwnerName].prototype, 'cookie'); // TODO: remove this condition after the GH-1649 fix

						    if (!this.isNativeCode(documentCookieDescriptor.get) || !this.isNativeCode(documentCookieDescriptor.get.toString)) {
						      try {
						        var parentNativeMethods = win.parent['%hammerhead%'].nativeMethods;
						        documentCookieDescriptor.get = parentNativeMethods.documentCookieGetter;
						        documentCookieDescriptor.set = parentNativeMethods.documentCookieSetter;
						      } catch (_unused) {} // eslint-disable-line no-empty

						    }

						    this.documentReferrerGetter = win.Object.getOwnPropertyDescriptor(docPrototype, 'referrer').get;
						    this.documentStyleSheetsGetter = win.Object.getOwnPropertyDescriptor(docPrototype, 'styleSheets').get;
						    this.documentActiveElementGetter = win.Object.getOwnPropertyDescriptor(docPrototype, 'activeElement').get;
						    this.documentScriptsGetter = win.Object.getOwnPropertyDescriptor(win[this.documentScriptsPropOwnerName].prototype, 'scripts').get;
						    this.documentCookieGetter = documentCookieDescriptor.get;
						    this.documentCookieSetter = documentCookieDescriptor.set;
						    var documentDocumentURIDescriptor = win.Object.getOwnPropertyDescriptor(docPrototype, 'documentURI');
						    if (documentDocumentURIDescriptor) this.documentDocumentURIGetter = documentDocumentURIDescriptor.get;
						    var documentTitleDescriptor = win.Object.getOwnPropertyDescriptor(docPrototype, 'title');
						    this.documentTitleGetter = documentTitleDescriptor.get;
						    this.documentTitleSetter = documentTitleDescriptor.set;
						  };

						  _proto.refreshElementMeths = function refreshElementMeths(doc, win) {
						    var _this = this;

						    win = win || window;

						    var createElement = function createElement(tagName) {
						      return _this.createElement.call(doc || document, tagName);
						    };

						    var nativeElement = createElement('div'); // Dom

						    this.appendChild = nativeElement.appendChild;
						    this.replaceChild = nativeElement.replaceChild;
						    this.cloneNode = nativeElement.cloneNode;
						    this.elementGetElementsByClassName = nativeElement.getElementsByClassName;
						    this.elementGetElementsByTagName = nativeElement.getElementsByTagName;
						    this.elementQuerySelector = nativeElement.querySelector;
						    this.elementQuerySelectorAll = nativeElement.querySelectorAll;
						    this.getAttribute = nativeElement.getAttribute;
						    this.getAttributeNS = nativeElement.getAttributeNS;
						    this.insertAdjacentHTML = nativeElement.insertAdjacentHTML;
						    this.insertBefore = nativeElement.insertBefore;
						    this.insertCell = createElement('tr').insertCell;
						    this.insertTableRow = createElement('table').insertRow;
						    this.insertTBodyRow = createElement('tbody').insertRow;
						    this.removeAttribute = nativeElement.removeAttribute;
						    this.removeAttributeNS = nativeElement.removeAttributeNS;
						    this.removeChild = nativeElement.removeChild;
						    this.setAttribute = nativeElement.setAttribute;
						    this.setAttributeNS = nativeElement.setAttributeNS;
						    this.hasAttribute = nativeElement.hasAttribute;
						    this.hasAttributeNS = nativeElement.hasAttributeNS;
						    this.hasAttributes = nativeElement.hasAttributes;
						    this.anchorToString = win.HTMLAnchorElement.prototype.toString;
						    this.matches = nativeElement.matches || nativeElement.msMatchesSelector;
						    this.closest = nativeElement.closest; // TODO: remove this condition after the GH-1649 fix

						    if (!this.isNativeCode(this.elementGetElementsByTagName)) {
						      try {
						        var parentNativeMethods = win.parent['%hammerhead%'].nativeMethods;
						        this.elementGetElementsByTagName = parentNativeMethods.elementGetElementsByTagName;
						      } // eslint-disable-next-line no-empty
						      catch (e) {}
						    } // Event


						    if (win.EventTarget) {
						      this.addEventListener = win.EventTarget.prototype.addEventListener;
						      this.removeEventListener = win.EventTarget.prototype.removeEventListener;
						      this.dispatchEvent = win.EventTarget.prototype.dispatchEvent;
						    } // NOTE: IE11 has no EventTarget
						    else {
						        this.addEventListener = nativeElement.addEventListener;
						        this.removeEventListener = nativeElement.removeEventListener;
						        this.dispatchEvent = nativeElement.dispatchEvent;
						      }

						    this.blur = nativeElement.blur;
						    this.click = nativeElement.click;
						    this.focus = nativeElement.focus; // @ts-ignore

						    this.select = window.TextRange ? createElement('body').createTextRange().select : null;
						    this.setSelectionRange = createElement('input').setSelectionRange;
						    this.textAreaSetSelectionRange = createElement('textarea').setSelectionRange;
						    this.svgFocus = win.SVGElement ? win.SVGElement.prototype.focus : this.focus;
						    this.svgBlur = win.SVGElement ? win.SVGElement.prototype.blur : this.blur; // Style
						    // NOTE: The 'style' descriptor is located in the Element.prototype in the Safari on IOS

						    this.htmlElementStylePropOwnerName = win.Element.prototype.hasOwnProperty('style') ? 'Element' : 'HTMLElement';
						    var htmlElementStyleDescriptor = win.Object.getOwnPropertyDescriptor(win[this.htmlElementStylePropOwnerName].prototype, 'style');
						    this.htmlElementStyleGetter = htmlElementStyleDescriptor.get; // NOTE: IE does not allow to set a style property

						    if (htmlElementStyleDescriptor.set) this.htmlElementStyleSetter = htmlElementStyleDescriptor.set;
						    var styleCssTextDescriptor = win.Object.getOwnPropertyDescriptor(win.CSSStyleDeclaration.prototype, 'cssText');
						    this.styleCssTextGetter = styleCssTextDescriptor.get;
						    this.styleCssTextSetter = styleCssTextDescriptor.set;
						  };

						  _proto._refreshGettersAndSetters = function _refreshGettersAndSetters(win, isInWorker) {
						    if (isInWorker === void 0) {
						      isInWorker = false;
						    }

						    win = win || window;
						    var winProto = win.constructor.prototype; // NOTE: Event properties is located in window prototype only in IE11

						    this.isEventPropsLocatedInProto = winProto.hasOwnProperty('onerror');
						    var eventPropsOwner = this.isEventPropsLocatedInProto ? winProto : win;
						    var winOnBeforeUnloadDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onbeforeunload');
						    var winOnPageHideDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onpagehide');
						    var winOnMessageDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onmessage');
						    var winOnErrorDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onerror');
						    var winOnHashChangeDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onhashchange');
						    this.winOnBeforeUnloadSetter = winOnBeforeUnloadDescriptor && winOnBeforeUnloadDescriptor.set;
						    this.winOnPageHideSetter = winOnPageHideDescriptor && winOnPageHideDescriptor.set;
						    this.winOnMessageSetter = winOnMessageDescriptor && winOnMessageDescriptor.set;
						    this.winOnErrorSetter = winOnErrorDescriptor && winOnErrorDescriptor.set;
						    this.winOnHashChangeSetter = winOnHashChangeDescriptor && winOnHashChangeDescriptor.set;
						    var winOnUnhandledRejectionDescriptor = win.Object.getOwnPropertyDescriptor(eventPropsOwner, 'onunhandledrejection');
						    if (winOnUnhandledRejectionDescriptor) this.winOnUnhandledRejectionSetter = winOnUnhandledRejectionDescriptor.set; // Getters

						    if (win.WebSocket) {
						      var urlPropDescriptor = win.Object.getOwnPropertyDescriptor(win.WebSocket.prototype, 'url');
						      if (urlPropDescriptor && urlPropDescriptor.get && urlPropDescriptor.configurable) this.webSocketUrlGetter = urlPropDescriptor.get;
						    }

						    this.messageEventOriginGetter = win.Object.getOwnPropertyDescriptor(win.MessageEvent.prototype, 'origin').get; // NOTE: At present we proxy only the PerformanceNavigationTiming.
						    // Another types of the PerformanceEntry will be fixed later
						    // https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry

						    if (win.PerformanceNavigationTiming) this.performanceEntryNameGetter = win.Object.getOwnPropertyDescriptor(win.PerformanceEntry.prototype, 'name').get;
						    var dataPropDescriptor = win.Object.getOwnPropertyDescriptor(win.MessageEvent.prototype, 'data'); // NOTE: This condition is used for the Android 6.0 browser

						    if (dataPropDescriptor) this.messageEventDataGetter = dataPropDescriptor.get;

						    if (win.fetch) {
						      this.responseStatusGetter = win.Object.getOwnPropertyDescriptor(win.Response.prototype, 'status').get;
						      this.responseTypeGetter = win.Object.getOwnPropertyDescriptor(win.Response.prototype, 'type').get;
						      this.responseUrlGetter = win.Object.getOwnPropertyDescriptor(win.Response.prototype, 'url').get;
						      this.requestUrlGetter = win.Object.getOwnPropertyDescriptor(win.Request.prototype, 'url').get;
						    }

						    if (win.XMLHttpRequest) {
						      var xhrResponseURLDescriptor = win.Object.getOwnPropertyDescriptor(win.XMLHttpRequest.prototype, 'responseURL'); // NOTE: IE doesn't support the 'responseURL' property

						      if (xhrResponseURLDescriptor) this.xhrResponseURLGetter = xhrResponseURLDescriptor.get;
						      this.xhrStatusGetter = win.Object.getOwnPropertyDescriptor(win.XMLHttpRequest.prototype, 'status').get;
						    } // eslint-disable-next-line no-restricted-properties


						    if (win.Window) {
						      // NOTE: The 'localStorage' and 'sessionStorage' properties is located in window prototype only in IE11
						      this.isStoragePropsLocatedInProto = win.Window.prototype.hasOwnProperty('localStorage');
						      var storagesPropsOwner = this.getStoragesPropsOwner(win);
						      this.winLocalStorageGetter = win.Object.getOwnPropertyDescriptor(storagesPropsOwner, 'localStorage').get;
						      this.winSessionStorageGetter = win.Object.getOwnPropertyDescriptor(storagesPropsOwner, 'sessionStorage').get;
						    }

						    if (isInWorker) return;
						    var objectDataDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLObjectElement.prototype, 'data');
						    var inputTypeDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'type');
						    var inputValueDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'value');
						    var inputDisabledDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'disabled');
						    var inputRequiredDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'required');
						    var textAreaValueDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLTextAreaElement.prototype, 'value');
						    var imageSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLImageElement.prototype, 'src');
						    var scriptSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLScriptElement.prototype, 'src');
						    var scriptIntegrityDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLScriptElement.prototype, 'integrity');
						    var embedSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLEmbedElement.prototype, 'src');
						    var sourceSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLSourceElement.prototype, 'src');
						    var mediaSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLMediaElement.prototype, 'src');
						    var inputSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'src');
						    var frameSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLFrameElement.prototype, 'src');
						    var iframeSrcDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'src');
						    var anchorHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'href');
						    var linkHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'href');
						    var linkIntegrityDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'integrity');
						    var linkRelDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'rel');
						    var linkAsDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLLinkElement.prototype, 'as');
						    var areaHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAreaElement.prototype, 'href');
						    var baseHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLBaseElement.prototype, 'href');
						    var anchorHostDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'host');
						    var anchorHostnameDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'hostname');
						    var anchorPathnameDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'pathname');
						    var anchorPortDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'port');
						    var anchorProtocolDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'protocol');
						    var anchorSearchDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'search');
						    var anchorTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'target');
						    var formTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLFormElement.prototype, 'target');
						    var areaTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAreaElement.prototype, 'target');
						    var baseTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLBaseElement.prototype, 'target');
						    var inputFormTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'formTarget');
						    var buttonFormTargetDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLButtonElement.prototype, 'formTarget');
						    var svgImageHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.SVGImageElement.prototype, 'href');
						    var svgAnimStrAnimValDescriptor = win.Object.getOwnPropertyDescriptor(win.SVGAnimatedString.prototype, 'animVal');
						    var svgAnimStrBaseValDescriptor = win.Object.getOwnPropertyDescriptor(win.SVGAnimatedString.prototype, 'baseVal');
						    var inputAutocompleteDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'autocomplete');
						    var formActionDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLFormElement.prototype, 'action');
						    var inputFormActionDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'formAction');
						    var buttonFormActionDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLButtonElement.prototype, 'formAction');
						    var nodeTextContentDescriptor = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'textContent');
						    var htmlElementInnerTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLElement.prototype, 'innerText');
						    var scriptTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLScriptElement.prototype, 'text');
						    var anchorTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'text');
						    var titleElementTextDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLTitleElement.prototype, 'text');
						    var iframeSandboxDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'sandbox');
						    var windowOriginDescriptor = win.Object.getOwnPropertyDescriptor(win, 'origin');

						    if (windowOriginDescriptor) {
						      this.windowOriginGetter = windowOriginDescriptor.get;
						      this.windowOriginSetter = windowOriginDescriptor.set;
						    } // NOTE: We need 'disabled' property only for Chrome.
						    // In Chrome it's located in HTMLInputElement.prototype
						    // But in IE11 it's located in HTMLElement.prototype
						    // So we need the null check


						    if (inputDisabledDescriptor) {
						      this.inputDisabledSetter = inputDisabledDescriptor.set;
						      this.inputDisabledGetter = inputDisabledDescriptor.get;
						    } // NOTE: Html properties is located in HTMLElement prototype in IE11 only


						    this.elementHTMLPropOwnerName = win.Element.prototype.hasOwnProperty('innerHTML') ? 'Element' : 'HTMLElement';
						    var elementInnerHTMLDescriptor = win.Object.getOwnPropertyDescriptor(win[this.elementHTMLPropOwnerName].prototype, 'innerHTML');
						    var elementOuterHTMLDescriptor = win.Object.getOwnPropertyDescriptor(win[this.elementHTMLPropOwnerName].prototype, 'outerHTML'); // Setters

						    this.objectDataSetter = objectDataDescriptor.set;
						    this.inputTypeSetter = inputTypeDescriptor.set;
						    this.inputValueSetter = inputValueDescriptor.set;
						    this.inputRequiredSetter = inputRequiredDescriptor.set;
						    this.textAreaValueSetter = textAreaValueDescriptor.set;
						    this.imageSrcSetter = imageSrcDescriptor.set;
						    this.scriptSrcSetter = scriptSrcDescriptor.set;
						    this.embedSrcSetter = embedSrcDescriptor.set;
						    this.sourceSrcSetter = sourceSrcDescriptor.set;
						    this.mediaSrcSetter = mediaSrcDescriptor.set;
						    this.inputSrcSetter = inputSrcDescriptor.set;
						    this.frameSrcSetter = frameSrcDescriptor.set;
						    this.iframeSrcSetter = iframeSrcDescriptor.set;
						    this.anchorHrefSetter = anchorHrefDescriptor.set;
						    this.linkHrefSetter = linkHrefDescriptor.set;
						    this.linkRelSetter = linkRelDescriptor.set;
						    this.linkAsSetter = linkAsDescriptor && linkAsDescriptor.set;
						    this.areaHrefSetter = areaHrefDescriptor.set;
						    this.baseHrefSetter = baseHrefDescriptor.set;
						    this.anchorHostSetter = anchorHostDescriptor.set;
						    this.anchorHostnameSetter = anchorHostnameDescriptor.set;
						    this.anchorPathnameSetter = anchorPathnameDescriptor.set;
						    this.anchorPortSetter = anchorPortDescriptor.set;
						    this.anchorProtocolSetter = anchorProtocolDescriptor.set;
						    this.anchorSearchSetter = anchorSearchDescriptor.set;
						    this.anchorTargetSetter = anchorTargetDescriptor.set;
						    this.formTargetSetter = formTargetDescriptor.set;
						    this.areaTargetSetter = areaTargetDescriptor.set;
						    this.baseTargetSetter = baseTargetDescriptor.set;
						    this.inputFormTargetSetter = inputFormTargetDescriptor.set;
						    this.buttonFormTargetSetter = buttonFormTargetDescriptor.set;
						    this.svgAnimStrBaseValSetter = svgAnimStrBaseValDescriptor.set;
						    this.inputAutocompleteSetter = inputAutocompleteDescriptor.set;
						    this.formActionSetter = formActionDescriptor.set;
						    this.inputFormActionSetter = inputFormActionDescriptor.set;
						    this.buttonFormActionSetter = buttonFormActionDescriptor.set;
						    this.iframeSandboxSetter = iframeSandboxDescriptor.set;
						    this.htmlElementOnloadSetter = win.Object.getOwnPropertyDescriptor(win.HTMLElement.prototype, 'onload').set;
						    this.nodeTextContentSetter = nodeTextContentDescriptor.set;
						    this.htmlElementInnerTextSetter = htmlElementInnerTextDescriptor.set;
						    this.scriptTextSetter = scriptTextDescriptor.set;
						    this.anchorTextSetter = anchorTextDescriptor.set;
						    this.elementInnerHTMLSetter = elementInnerHTMLDescriptor.set;
						    this.elementOuterHTMLSetter = elementOuterHTMLDescriptor.set; // NOTE: Some browsers (for example, Edge, Internet Explorer 11, Safari) don't support the 'integrity' property.

						    if (scriptIntegrityDescriptor && linkIntegrityDescriptor) {
						      this.scriptIntegritySetter = scriptIntegrityDescriptor.set;
						      this.linkIntegritySetter = linkIntegrityDescriptor.set;
						    }

						    this.titleElementTextSetter = titleElementTextDescriptor.set; // NOTE: the classList property is located in HTMLElement prototype in IE11

						    this.elementClassListPropOwnerName = win.Element.prototype.hasOwnProperty('classList') ? 'Element' : 'HTMLElement';
						    this.elementClassListGetter = win.Object.getOwnPropertyDescriptor(win[this.elementClassListPropOwnerName].prototype, 'classList').get;
						    this.htmlCollectionLengthGetter = win.Object.getOwnPropertyDescriptor(win.HTMLCollection.prototype, 'length').get;
						    this.nodeListLengthGetter = win.Object.getOwnPropertyDescriptor(win.NodeList.prototype, 'length').get;
						    this.elementChildElementCountGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'childElementCount').get;
						    this.inputFilesGetter = win.Object.getOwnPropertyDescriptor(win.HTMLInputElement.prototype, 'files').get;
						    this.styleSheetHrefGetter = win.Object.getOwnPropertyDescriptor(win.StyleSheet.prototype, 'href').get;
						    this.objectDataGetter = objectDataDescriptor.get;
						    this.inputTypeGetter = inputTypeDescriptor.get;
						    this.inputValueGetter = inputValueDescriptor.get;
						    this.inputRequiredGetter = inputRequiredDescriptor.get;
						    this.textAreaValueGetter = textAreaValueDescriptor.get;
						    this.imageSrcGetter = imageSrcDescriptor.get;
						    this.scriptSrcGetter = scriptSrcDescriptor.get;
						    this.embedSrcGetter = embedSrcDescriptor.get;
						    this.sourceSrcGetter = sourceSrcDescriptor.get;
						    this.mediaSrcGetter = mediaSrcDescriptor.get;
						    this.inputSrcGetter = inputSrcDescriptor.get;
						    this.frameSrcGetter = frameSrcDescriptor.get;
						    this.iframeSrcGetter = iframeSrcDescriptor.get;
						    this.anchorHrefGetter = anchorHrefDescriptor.get;
						    this.linkHrefGetter = linkHrefDescriptor.get;
						    this.linkRelGetter = linkRelDescriptor.get;
						    this.areaHrefGetter = areaHrefDescriptor.get;
						    this.baseHrefGetter = baseHrefDescriptor.get;
						    this.anchorHostGetter = anchorHostDescriptor.get;
						    this.anchorHostnameGetter = anchorHostnameDescriptor.get;
						    this.anchorPathnameGetter = anchorPathnameDescriptor.get;
						    this.anchorPortGetter = anchorPortDescriptor.get;
						    this.anchorProtocolGetter = anchorProtocolDescriptor.get;
						    this.anchorSearchGetter = anchorSearchDescriptor.get;
						    this.anchorTargetGetter = anchorTargetDescriptor.get;
						    this.formTargetGetter = formTargetDescriptor.get;
						    this.areaTargetGetter = areaTargetDescriptor.get;
						    this.baseTargetGetter = baseTargetDescriptor.get;
						    this.inputFormTargetGetter = inputFormTargetDescriptor.get;
						    this.buttonFormTargetGetter = buttonFormTargetDescriptor.get;
						    this.svgImageHrefGetter = svgImageHrefDescriptor.get;
						    this.svgAnimStrAnimValGetter = svgAnimStrAnimValDescriptor.get;
						    this.svgAnimStrBaseValGetter = svgAnimStrBaseValDescriptor.get;
						    this.inputAutocompleteGetter = inputAutocompleteDescriptor.get;
						    this.formActionGetter = formActionDescriptor.get;
						    this.inputFormActionGetter = inputFormActionDescriptor.get;
						    this.buttonFormActionGetter = buttonFormActionDescriptor.get;
						    this.iframeSandboxGetter = iframeSandboxDescriptor.get;
						    this.contentWindowGetter = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'contentWindow').get;
						    this.contentDocumentGetter = win.Object.getOwnPropertyDescriptor(win.HTMLIFrameElement.prototype, 'contentDocument').get;
						    this.frameContentWindowGetter = win.Object.getOwnPropertyDescriptor(win.HTMLFrameElement.prototype, 'contentWindow').get;
						    this.nodeTextContentGetter = nodeTextContentDescriptor.get;
						    this.htmlElementInnerTextGetter = htmlElementInnerTextDescriptor.get;
						    this.scriptTextGetter = scriptTextDescriptor.get;
						    this.anchorTextGetter = anchorTextDescriptor.get;
						    this.elementInnerHTMLGetter = elementInnerHTMLDescriptor.get;
						    this.elementOuterHTMLGetter = elementOuterHTMLDescriptor.get;
						    this.nodeFirstChildGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'firstChild').get;
						    this.nodeLastChildGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'lastChild').get;
						    this.nodeNextSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'nextSibling').get;
						    this.nodePrevSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'previousSibling').get;
						    this.nodeParentNodeGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'parentNode').get;
						    this.nodeChildNodesGetter = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'childNodes').get;
						    this.elementFirstElementChildGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'firstElementChild').get;
						    this.elementLastElementChildGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'lastElementChild').get;
						    this.elementNextElementSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'nextElementSibling').get;
						    this.elementPrevElementSiblingGetter = win.Object.getOwnPropertyDescriptor(win.Element.prototype, 'previousElementSibling').get; // NOTE: Some browsers (for example, Edge, Internet Explorer 11, Safari) don't support the 'integrity' property.

						    if (scriptIntegrityDescriptor && linkIntegrityDescriptor) {
						      this.scriptIntegrityGetter = scriptIntegrityDescriptor.get;
						      this.linkIntegrityGetter = linkIntegrityDescriptor.get;
						    }

						    var anchorOriginDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLAnchorElement.prototype, 'origin'); // NOTE: IE and Edge don't support origin property

						    if (anchorOriginDescriptor) this.anchorOriginGetter = anchorOriginDescriptor.get;
						    var cssStyleSheetHrefDescriptor = win.Object.getOwnPropertyDescriptor(win.CSSStyleSheet.prototype, 'href'); // NOTE: IE11 doesn't support the 'href' property

						    if (cssStyleSheetHrefDescriptor) this.cssStyleSheetHrefGetter = cssStyleSheetHrefDescriptor.get;
						    var nodeBaseURIDescriptor = win.Object.getOwnPropertyDescriptor(win.Node.prototype, 'baseURI'); // NOTE: IE11 doesn't support the 'baseURI' property

						    if (nodeBaseURIDescriptor) this.nodeBaseURIGetter = nodeBaseURIDescriptor.get; // NOTE: The 'attributes' property is located in Node prototype in IE11 only

						    this.elementAttributesPropOwnerName = win.Element.prototype.hasOwnProperty('attributes') ? 'Element' : 'Node';
						    this.elementAttributesGetter = win.Object.getOwnPropertyDescriptor(win[this.elementAttributesPropOwnerName].prototype, 'attributes').get;
						    var htmlManifestDescriptor = win.Object.getOwnPropertyDescriptor(win.HTMLHtmlElement.prototype, 'manifest'); // NOTE: Only the Safari browser supports the 'manifest' property

						    if (htmlManifestDescriptor) {
						      this.htmlManifestGetter = htmlManifestDescriptor.get;
						      this.htmlManifestSetter = htmlManifestDescriptor.set;
						    }

						    this.titleElementTextGetter = titleElementTextDescriptor.get; // MutationRecord

						    this.mutationRecordNextSiblingGetter = win.Object.getOwnPropertyDescriptor(win.MutationRecord.prototype, 'nextSibling').get;
						    this.mutationRecordPrevSiblingGetter = win.Object.getOwnPropertyDescriptor(win.MutationRecord.prototype, 'previousSibling').get;
						  };

						  _proto.refreshWindowMeths = function refreshWindowMeths(win, isInWorker) {
						    if (isInWorker === void 0) {
						      isInWorker = false;
						    }

						    win = win || window;
						    var winProto = win.constructor.prototype; // Dom

						    this.eval = win.eval;
						    this.formSubmit = win.HTMLFormElement && win.HTMLFormElement.prototype.submit;
						    this.documentFragmentQuerySelector = win.DocumentFragment && win.DocumentFragment.prototype.querySelector;
						    this.documentFragmentQuerySelectorAll = win.DocumentFragment && win.DocumentFragment.prototype.querySelectorAll;
						    this.preventDefault = win.Event.prototype.preventDefault;
						    this.historyPushState = win.history && win.history.pushState;
						    this.historyReplaceState = win.history && win.history.replaceState;
						    this.postMessage = win.postMessage || winProto.postMessage;
						    this.windowOpen = win.open || winProto.open;
						    this.setTimeout = win.setTimeout || winProto.setTimeout;
						    this.setInterval = win.setInterval || winProto.setInterval;
						    this.clearTimeout = win.clearTimeout || winProto.clearTimeout;
						    this.clearInterval = win.clearInterval || winProto.clearInterval;
						    this.registerProtocolHandler = win.navigator.registerProtocolHandler;
						    this.sendBeacon = win.navigator.sendBeacon;

						    if (win.XMLHttpRequest) {
						      // NOTE: IE11 has no EventTarget so we should save "Event" methods separately
						      var xhrEventProto = (win.EventTarget || win.XMLHttpRequest).prototype;
						      this.xhrAbort = win.XMLHttpRequest.prototype.abort;
						      this.xhrOpen = win.XMLHttpRequest.prototype.open;
						      this.xhrSend = win.XMLHttpRequest.prototype.send;
						      this.xhrAddEventListener = xhrEventProto.addEventListener;
						      this.xhrRemoveEventListener = xhrEventProto.removeEventListener;
						      this.xhrDispatchEvent = xhrEventProto.dispatchEvent;
						      this.xhrGetResponseHeader = win.XMLHttpRequest.prototype.getResponseHeader;
						      this.xhrGetAllResponseHeaders = win.XMLHttpRequest.prototype.getAllResponseHeaders;
						      this.xhrSetRequestHeader = win.XMLHttpRequest.prototype.setRequestHeader;
						      this.xhrOverrideMimeType = win.XMLHttpRequest.prototype.overrideMimeType;
						    }

						    try {
						      this.registerServiceWorker = win.navigator.serviceWorker.register;
						      this.getRegistrationServiceWorker = win.navigator.serviceWorker.getRegistration;
						    } catch (e) {
						      this.registerServiceWorker = null;
						      this.getRegistrationServiceWorker = null;
						    }

						    this.createContextualFragment = win.Range && win.Range.prototype.createContextualFragment;
						    var nativePerformance = win.performance;

						    if (nativePerformance) {
						      // eslint-disable-next-line no-restricted-properties
						      var nativePerformanceNow = win.performance.now || win.Performance.prototype.now;

						      this.performanceNow = function () {
						        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
						          args[_key] = arguments[_key];
						        }

						        return nativePerformanceNow.apply(nativePerformance, args);
						      };
						    } // Fetch


						    this.fetch = win.fetch;
						    this.Request = win.Request;

						    if (win.Headers) {
						      this.Headers = win.Headers;
						      this.headersSet = win.Headers.prototype.set;
						      this.headersGet = win.Headers.prototype.get;
						      this.headersHas = win.Headers.prototype.has;
						      this.headersDelete = win.Headers.prototype.delete;
						      this.headersEntries = win.Headers.prototype.entries;
						      this.headersForEach = win.Headers.prototype.forEach;
						    } // Event
						    // NOTE: IE11 has no EventTarget so we should save "Event" methods separately


						    if (!win.EventLisener) {
						      this.windowAddEventListener = win.addEventListener || winProto.addEventListener;
						      this.windowRemoveEventListener = win.removeEventListener || winProto.removeEventListener;
						      this.windowDispatchEvent = win.dispatchEvent;
						    }

						    this.WindowPointerEvent = win.PointerEvent || winProto.PointerEvent;
						    this.WindowMSPointerEvent = win.MSPointerEvent || winProto.MSPointerEvent;
						    this.WindowTouch = win.Touch || winProto.Touch;
						    this.WindowTouchEvent = win.TouchEvent || winProto.TouchEvent;
						    this.WindowKeyboardEvent = win.KeyboardEvent || winProto.KeyboardEvent;
						    this.WindowFocusEvent = win.FocusEvent || winProto.FocusEvent;
						    this.WindowTextEvent = win.TextEvent || winProto.TextEvent;
						    this.WindowInputEvent = win.InputEvent || winProto.InputEvent;
						    this.WindowMouseEvent = win.MouseEvent || winProto.MouseEvent;
						    this.canvasContextDrawImage = win.CanvasRenderingContext2D && win.CanvasRenderingContext2D.prototype.drawImage; // FormData

						    this.formDataAppend = win.FormData && win.FormData.prototype.append; // DateTime

						    this.date = win.Date;
						    this.dateNow = win.Date.now; // eslint-disable-line no-restricted-properties
						    // Math

						    this.math = win.Math;
						    this.mathRandom = win.Math.random; // Object

						    this.objectToString = win.Object.prototype.toString;
						    this.objectAssign = win.Object.assign;
						    this.objectKeys = win.Object.keys;
						    this.objectDefineProperty = win.Object.defineProperty;
						    this.objectDefineProperties = win.Object.defineProperties;
						    this.objectCreate = win.Object.create;
						    this.objectIsExtensible = win.Object.isExtensible;
						    this.objectIsFrozen = win.Object.isFrozen;
						    this.objectGetOwnPropertyDescriptor = win.Object.getOwnPropertyDescriptor;
						    this.objectHasOwnProperty = win.Object.hasOwnProperty;
						    this.objectGetOwnPropertyNames = win.Object.getOwnPropertyNames;
						    this.objectGetPrototypeOf = win.Object.getPrototypeOf;
						    this.objectGetOwnPropertySymbols = win.Object.getOwnPropertySymbols; // Array

						    this.arraySlice = win.Array.prototype.slice;
						    this.arrayConcat = win.Array.prototype.concat;
						    this.arrayFilter = win.Array.prototype.filter;
						    this.arrayMap = win.Array.prototype.map;
						    this.arrayJoin = win.Array.prototype.join;
						    this.arraySplice = win.Array.prototype.splice;
						    this.arrayForEach = win.Array.prototype.forEach;
						    this.arrayFrom = win.Array.from;
						    this.DOMParserParseFromString = win.DOMParser && win.DOMParser.prototype.parseFromString;
						    this.arrayBufferIsView = win.ArrayBuffer.prototype.constructor.isView; // NOTE: this section relates to getting properties from DOM classes

						    if (!isInWorker) {
						      // DOMTokenList
						      this.tokenListAdd = win.DOMTokenList.prototype.add;
						      this.tokenListRemove = win.DOMTokenList.prototype.remove;
						      this.tokenListReplace = win.DOMTokenList.prototype.replace;
						      this.tokenListSupports = win.DOMTokenList.prototype.supports;
						      this.tokenListToggle = win.DOMTokenList.prototype.toggle;
						      this.tokenListContains = win.DOMTokenList.prototype.contains; // Stylesheets

						      this.styleGetPropertyValue = win.CSSStyleDeclaration.prototype.getPropertyValue;
						      this.styleSetProperty = win.CSSStyleDeclaration.prototype.setProperty;
						      this.styleRemoveProperty = win.CSSStyleDeclaration.prototype.removeProperty;
						      this.styleInsertRule = win.CSSStyleSheet.prototype.insertRule;
						      this.scrollTo = win.scrollTo;
						    }

						    if (win.Promise) {
						      this.promiseThen = win.Promise.prototype.then;
						      this.promiseReject = win.Promise.reject;
						    } // Console


						    this.console = win.console;

						    if (this.console) {
						      this.consoleMeths = {
						        log: win.console.log,
						        warn: win.console.warn,
						        error: win.console.error,
						        info: win.console.info
						      };
						    }

						    this.crypto = win.crypto || win.msCrypto;
						    this.cryptoGetRandomValues = this.crypto && this.crypto.getRandomValues;
						    this.refreshClasses(win);

						    this._refreshGettersAndSetters(win, isInWorker);
						  };

						  _proto.refreshClasses = function refreshClasses(win) {
						    this.windowClass = win.Window;
						    this.documentClass = win.Document;
						    this.locationClass = win.Location;
						    this.elementClass = win.Element;
						    this.svgElementClass = win.SVGElement;
						    this.Worker = win.Worker;
						    this.MessageChannel = win.MessageChannel;
						    this.ArrayBuffer = win.ArrayBuffer;
						    this.Uint8Array = win.Uint8Array;
						    this.Uint16Array = win.Uint16Array;
						    this.Uint32Array = win.Uint32Array;
						    this.DataView = win.DataView;
						    this.Blob = win.Blob;
						    this.XMLHttpRequest = win.XMLHttpRequest;
						    this.Image = win.Image;
						    this.Function = win.Function;
						    this.functionToString = win.Function.toString;
						    this.Error = win.Error;
						    this.FontFace = win.FontFace;
						    this.StorageEvent = win.StorageEvent;
						    this.MutationObserver = win.MutationObserver;
						    this.EventSource = win.EventSource;
						    this.Proxy = win.Proxy;
						    this.WebSocket = win.WebSocket;
						    this.HTMLCollection = win.HTMLCollection;
						    this.NodeList = win.NodeList;
						    this.Node = win.Node;
						    this.URL = win.URL;
						    this.Proxy = win.Proxy;
						    this.DataTransfer = win.DataTransfer;
						    this.DataTransferItemList = win.DataTransferItemList;
						    this.DataTransferItem = win.DataTransferItem;
						    this.FileList = win.FileList; // NOTE: non-IE11 case. window.File in IE11 is not constructable.

						    if (win.File && typeof win.File === 'function') this.File = win.File;
						  };

						  _proto.refreshElectronMeths = function refreshElectronMeths(vmModule) {
						    if (this.createScript && this.createScript.toString() !== vmModule.createScript.toString()) return false;
						    this.createScript = vmModule.createScript;
						    this.runInDebugContext = vmModule.runInDebugContext;
						    this.runInContext = vmModule.runInContext;
						    this.runInNewContext = vmModule.runInNewContext;
						    this.runInThisContext = vmModule.runInThisContext;
						    return true;
						  };

						  NativeMethods._ensureDocumentMethodRestore = function _ensureDocumentMethodRestore(document, prototype, methodName, savedNativeMethod) {
						    prototype[methodName] = savedNativeMethod;
						    if (document[methodName] !== prototype[methodName]) document[methodName] = savedNativeMethod;
						  };

						  _proto.restoreDocumentMeths = function restoreDocumentMeths(window, document) {
						    var docPrototype = window.Document.prototype;

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createDocumentFragment', this.createDocumentFragment);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createElement', this.createElement);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createElementNS', this.createElementNS);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'elementFromPoint', this.elementFromPoint);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'caretRangeFromPoint', this.caretRangeFromPoint);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'caretPositionFromPoint', this.caretPositionFromPoint);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementById', this.getElementById);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementsByClassName', this.getElementsByClassName);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementsByName', this.getElementsByName);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'getElementsByTagName', this.getElementsByTagName);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'querySelector', this.querySelector);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'querySelectorAll', this.querySelectorAll); // Event
						    // NOTE: IE11 has no EventTarget


						    if (!window.EventTarget) {
						      NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'addEventListener', this.documentAddEventListener);

						      NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'removeEventListener', this.documentRemoveEventListener);
						    }

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createEvent', this.documentCreateEvent);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createTouch', this.documentCreateTouch);

						    NativeMethods._ensureDocumentMethodRestore(document, docPrototype, 'createTouchList', this.documentCreateTouchList);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentOpenPropOwnerName].prototype, 'open', this.documentOpen);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentClosePropOwnerName].prototype, 'close', this.documentClose);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentWritePropOwnerName].prototype, 'write', this.documentWrite);

						    NativeMethods._ensureDocumentMethodRestore(document, window[this.documentWriteLnPropOwnerName].prototype, 'writeln', this.documentWriteLn);
						  };

						  _proto.refreshIfNecessary = function refreshIfNecessary(doc, win) {
						    var _this2 = this;

						    var tryToExecuteCode = function tryToExecuteCode(func) {
						      try {
						        return func();
						      } catch (e) {
						        return true;
						      }
						    };

						    var needToRefreshDocumentMethods = tryToExecuteCode(function () {
						      return !doc.createElement || _this2.createElement.toString() === document.createElement.toString();
						    });
						    var needToRefreshElementMethods = tryToExecuteCode(function () {
						      var nativeElement = _this2.createElement.call(doc, 'div');

						      return nativeElement.getAttribute.toString() === _this2.getAttribute.toString();
						    });
						    var needToRefreshWindowMethods = tryToExecuteCode(function () {
						      _this2.setTimeout.call(win, function () {
						        return void 0;
						      }, 0); //@ts-ignore


						      return win.XMLHttpRequest.prototype.open.toString() === _this2.xhrOpen.toString();
						    }); // NOTE: T173709

						    if (needToRefreshDocumentMethods) this.refreshDocumentMeths(doc, win);
						    if (needToRefreshElementMethods) this.refreshElementMeths(doc, win); // NOTE: T239109

						    if (needToRefreshWindowMethods) this.refreshWindowMeths(win);
						  };

						  _proto.isNativeCode = function isNativeCode(fn) {
						    return NATIVE_CODE_RE.test(fn.toString());
						  };

						  return NativeMethods;
						}();

						var _default = new NativeMethods();

						exports.default = _default;
						module.exports = exports.default;
					},
					"xhr.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;

						var _base = _interopRequireDefault(require("./base"));

						var _nativeMethods = _interopRequireDefault(require("./native-methods"));

						var _url = require("../utils/url");

						var _builtinHeaderNames = _interopRequireDefault(require("../../request-pipeline/builtin-header-names"));

						var _internalHeaderNames = _interopRequireDefault(require("../../request-pipeline/internal-header-names"));

						var _headers = require("../utils/headers");

						var _destinationLocation = require("../utils/destination-location");

						var _propertyOverriding = require("../utils/property-overriding");

						var _sameOriginCheckFailedStatusCode = _interopRequireDefault(require("../../request-pipeline/xhr/same-origin-check-failed-status-code"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

						var XHR_READY_STATES = ['UNSENT', 'OPENED', 'HEADERS_RECEIVED', 'LOADING', 'DONE'];

						var XhrSandbox = /*#__PURE__*/function (_SandboxBase) {
						  _inheritsLoose(XhrSandbox, _SandboxBase);

						  function XhrSandbox(_cookieSandbox) {
						    var _this;

						    _this = _SandboxBase.call(this) || this;
						    _this._cookieSandbox = _cookieSandbox;
						    _this.XHR_COMPLETED_EVENT = 'hammerhead|event|xhr-completed';
						    _this.XHR_ERROR_EVENT = 'hammerhead|event|xhr-error';
						    _this.BEFORE_XHR_SEND_EVENT = 'hammerhead|event|before-xhr-send';
						    return _this;
						  }

						  XhrSandbox.createNativeXHR = function createNativeXHR() {
						    var xhr = new _nativeMethods.default.XMLHttpRequest();
						    xhr.open = _nativeMethods.default.xhrOpen;
						    xhr.abort = _nativeMethods.default.xhrAbort;
						    xhr.send = _nativeMethods.default.xhrSend;
						    xhr.addEventListener = _nativeMethods.default.xhrAddEventListener || _nativeMethods.default.addEventListener;
						    xhr.removeEventListener = _nativeMethods.default.xhrRemoveEventListener || _nativeMethods.default.removeEventListener;
						    xhr.setRequestHeader = _nativeMethods.default.xhrSetRequestHeader;
						    xhr.getResponseHeader = _nativeMethods.default.xhrGetResponseHeader;
						    xhr.getAllResponseHeaders = _nativeMethods.default.xhrGetAllResponseHeaders;
						    xhr.overrideMimeType = _nativeMethods.default.xhrOverrideMimeType;
						    xhr.dispatchEvent = _nativeMethods.default.xhrDispatchEvent || _nativeMethods.default.dispatchEvent;
						    return xhr;
						  };

						  XhrSandbox.openNativeXhr = function openNativeXhr(xhr, url, isAsync) {
						    xhr.open('POST', url, isAsync);
						    xhr.setRequestHeader(_builtinHeaderNames.default.cacheControl, 'no-cache, no-store, must-revalidate');
						  };

						  var _proto = XhrSandbox.prototype;

						  _proto.attach = function attach(window) {
						    _SandboxBase.prototype.attach.call(this, window);

						    var xhrSandbox = this;
						    var xmlHttpRequestProto = window.XMLHttpRequest.prototype;

						    var xmlHttpRequestToString = _nativeMethods.default.XMLHttpRequest.toString();

						    var emitXhrCompletedEvent = function emitXhrCompletedEvent() {
						      var nativeRemoveEventListener = _nativeMethods.default.xhrRemoveEventListener || _nativeMethods.default.removeEventListener;
						      xhrSandbox.emit(xhrSandbox.XHR_COMPLETED_EVENT, {
						        xhr: this
						      });
						      nativeRemoveEventListener.call(this, 'loadend', emitXhrCompletedEvent);
						    };

						    var syncCookieWithClientIfNecessary = function syncCookieWithClientIfNecessary() {
						      if (this.readyState < this.HEADERS_RECEIVED) return;
						      var nativeRemoveEventListener = _nativeMethods.default.xhrRemoveEventListener || _nativeMethods.default.removeEventListener;

						      xhrSandbox._cookieSandbox.syncCookie();

						      nativeRemoveEventListener.call(this, 'readystatechange', syncCookieWithClientIfNecessary);
						    };

						    var xmlHttpRequestWrapper = function xmlHttpRequestWrapper() {
						      var nativeAddEventListener = _nativeMethods.default.xhrAddEventListener || _nativeMethods.default.addEventListener;
						      var xhr = new _nativeMethods.default.XMLHttpRequest();
						      nativeAddEventListener.call(xhr, 'loadend', emitXhrCompletedEvent);
						      nativeAddEventListener.call(xhr, 'readystatechange', syncCookieWithClientIfNecessary);
						      return xhr;
						    };

						    for (var _i2 = 0; _i2 < XHR_READY_STATES.length; _i2++) {
						      var readyState = XHR_READY_STATES[_i2];

						      _nativeMethods.default.objectDefineProperty(xmlHttpRequestWrapper, readyState, {
						        value: XMLHttpRequest[readyState],
						        enumerable: true
						      });
						    }

						    window.XMLHttpRequest = xmlHttpRequestWrapper;
						    xmlHttpRequestWrapper.prototype = xmlHttpRequestProto;

						    xmlHttpRequestWrapper.toString = function () {
						      return xmlHttpRequestToString;
						    }; // NOTE: We cannot just assign constructor property in OS X 10.11 safari 9.0


						    _nativeMethods.default.objectDefineProperty(xmlHttpRequestProto, 'constructor', {
						      value: xmlHttpRequestWrapper
						    });

						    xmlHttpRequestProto.abort = function () {
						      _nativeMethods.default.xhrAbort.apply(this, arguments);

						      xhrSandbox.emit(xhrSandbox.XHR_ERROR_EVENT, {
						        err: new Error('XHR aborted'),
						        xhr: this
						      });
						    }; // NOTE: Redirect all requests to the Hammerhead proxy and ensure that requests don't
						    // violate Same Origin Policy.


						    xmlHttpRequestProto.open = function () {
						      var url = arguments[1];
						      var urlIsString = typeof url === 'string';
						      arguments[1] = (0, _url.getProxyUrl)(urlIsString ? url : String(url));

						      _nativeMethods.default.xhrOpen.apply(this, arguments);
						    };

						    xmlHttpRequestProto.send = function () {
						      xhrSandbox.emit(xhrSandbox.BEFORE_XHR_SEND_EVENT, {
						        xhr: this
						      }); // NOTE: As all requests are passed to the proxy, we need to perform Same Origin Policy compliance checks on the
						      // server side. So, we pass the CORS support flag to inform the proxy that it can analyze the
						      // Access-Control_Allow_Origin flag and skip "preflight" requests.
						      // eslint-disable-next-line no-restricted-properties

						      _nativeMethods.default.xhrSetRequestHeader.call(this, _internalHeaderNames.default.origin, (0, _destinationLocation.getOriginHeader)());

						      _nativeMethods.default.xhrSetRequestHeader.call(this, _internalHeaderNames.default.credentials, this.withCredentials ? 'include' : 'same-origin');

						      _nativeMethods.default.xhrSend.apply(this, arguments); // NOTE: For xhr with the sync mode


						      if (this.readyState === this.DONE) emitXhrCompletedEvent.call(this);
						      syncCookieWithClientIfNecessary.call(this);
						    };

						    xmlHttpRequestProto.setRequestHeader = function () {
						      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
						        args[_key] = arguments[_key];
						      }

						      args[0] = (0, _headers.transformHeaderNameToInternal)(args[0]);
						      return _nativeMethods.default.xhrSetRequestHeader.apply(this, args);
						    };

						    (0, _propertyOverriding.overrideDescriptor)(window.XMLHttpRequest.prototype, 'status', {
						      getter: function getter() {
						        var status = _nativeMethods.default.xhrStatusGetter.call(this);

						        return status === _sameOriginCheckFailedStatusCode.default ? 0 : status;
						      }
						    });

						    if (_nativeMethods.default.xhrResponseURLGetter) {
						      (0, _propertyOverriding.overrideDescriptor)(window.XMLHttpRequest.prototype, 'responseURL', {
						        getter: function getter() {
						          return (0, _url.getDestinationUrl)(_nativeMethods.default.xhrResponseURLGetter.call(this));
						        }
						      });
						    }

						    xmlHttpRequestProto.getResponseHeader = function () {
						      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						        args[_key2] = arguments[_key2];
						      }

						      args[0] = (0, _headers.transformHeaderNameToInternal)(args[0]);
						      return _nativeMethods.default.xhrGetResponseHeader.apply(this, args);
						    };

						    xmlHttpRequestProto.getAllResponseHeaders = function () {
						      var allHeaders = _nativeMethods.default.xhrGetAllResponseHeaders.apply(this, arguments);

						      return allHeaders.replace(_internalHeaderNames.default.wwwAuthenticate, _builtinHeaderNames.default.wwwAuthenticate).replace(_internalHeaderNames.default.proxyAuthenticate, _builtinHeaderNames.default.proxyAuthenticate);
						    };
						  };

						  return XhrSandbox;
						}(_base.default);

						exports.default = XhrSandbox;
						module.exports = exports.default;
					}
				},
				"settings.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.default = void 0;

					var Settings = /*#__PURE__*/function () {
					  function Settings() {
					    this._settings = {
					      isFirstPageLoad: true,
					      sessionId: '',
					      forceProxySrcForImage: false,
					      crossDomainProxyPort: '',
					      referer: '',
					      serviceMsgUrl: '',
					      transportWorkerUrl: '',
					      iframeTaskScriptTemplate: '',
					      cookie: '',
					      allowMultipleWindows: false,
					      isRecordMode: false,
					      windowId: ''
					    };
					  }

					  var _proto = Settings.prototype;

					  _proto.set = function set(value) {
					    this._settings = value;
					  };

					  _proto.get = function get() {
					    return this._settings;
					  };

					  return Settings;
					}();

					var settings = new Settings();
					var _default = settings;
					exports.default = _default;
					module.exports = exports.default;
				},
				"utils": {
					"browser.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.isElectron = exports.isWebKit = exports.isSafari = exports.isChrome = exports.isMSEdge = exports.isFirefox = exports.isIE9 = exports.isIE10 = exports.isIE11 = exports.isIE = exports.webkitVersion = exports.fullVersion = exports.version = exports.isTablet = exports.isMobile = exports.isIOS = exports.isAndroid = exports.isMacPlatform = exports.compareVersions = void 0;

						var _bowser = _interopRequireDefault(require("bowser"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var userAgent = navigator.userAgent.toLowerCase(); //@ts-ignore

						var info = _bowser.default._detect(userAgent);

						var webkitVersionMatch = userAgent.match(/applewebkit\/(\d+(:?\.\d+)*)/); //Helper
						//@ts-ignore

						var compareVersions = _bowser.default.compareVersions; //Platforms

						exports.compareVersions = compareVersions;
						var isMacPlatform = !!info.mac;
						exports.isMacPlatform = isMacPlatform;
						var isAndroid = !!info.android;
						exports.isAndroid = isAndroid;
						var isIOS = !!info.ios;
						exports.isIOS = isIOS;
						var isMobile = !!info.mobile;
						exports.isMobile = isMobile;
						var isTablet = !!info.tablet; //Browsers

						exports.isTablet = isTablet;
						var version = parseInt(info.version, 10);
						exports.version = version;
						var fullVersion = info.version;
						exports.fullVersion = fullVersion;
						var webkitVersion = webkitVersionMatch && webkitVersionMatch[1] || '';
						exports.webkitVersion = webkitVersion;
						var isIE = !!(info.msie || info.msedge);
						exports.isIE = isIE;
						var isIE11 = isIE && version === 11;
						exports.isIE11 = isIE11;
						var isIE10 = isIE && version === 10;
						exports.isIE10 = isIE10;
						var isIE9 = isIE && version === 9;
						exports.isIE9 = isIE9;
						var isFirefox = !!info.firefox;
						exports.isFirefox = isFirefox;
						var isMSEdge = !!info.msedge;
						exports.isMSEdge = isMSEdge;
						var isChrome = !!info.chrome;
						exports.isChrome = isChrome;
						var isSafari = !!info.safari;
						exports.isSafari = isSafari;
						var isWebKit = !!(info.webkit || info.blink);
						exports.isWebKit = isWebKit;
						var isElectron = /electron/g.test(userAgent);
						exports.isElectron = isElectron;
					},
					"destination-location.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.getLocation = getLocation;
						exports.forceLocation = forceLocation;
						exports.sameOriginCheck = sameOriginCheck;
						exports.resolveUrl = resolveUrl;
						exports.get = get;
						exports.withHash = withHash;
						exports.getParsed = getParsed;
						exports.getOriginHeader = getOriginHeader;

						var sharedUrlUtils = _interopRequireWildcard(require("../../utils/url"));

						var domUtils = _interopRequireWildcard(require("./dom"));

						var urlResolver = _interopRequireWildcard(require("./url-resolver"));

						var _settings = _interopRequireDefault(require("../settings"));

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						var _globalContextInfo = _interopRequireDefault(require("./global-context-info"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						var forcedLocation = null; // NOTE: exposed only for tests

						function getLocation() {
						  // NOTE: Used for testing. Unfortunately, we cannot override the 'getLocation' method in a test.
						  if (forcedLocation) return forcedLocation;
						  var globalCtx = (0, _globalContextInfo.default)().global;
						  var frameElement = domUtils.getFrameElement(globalCtx); // NOTE: Fallback to the owner page's URL if we are in an iframe without src.

						  if (frameElement && domUtils.isIframeWithoutSrc(frameElement)) return _settings.default.get().referer;
						  return globalCtx.location.toString();
						} // NOTE: We need to be able to force the page location. During the test, Hammerhead should think that it is on the
						// proxied page, not in the test environment. Unfortunately, we cannot do it in any other way.


						function forceLocation(url) {
						  forcedLocation = url;
						}

						function sameOriginCheck(location, checkedUrl) {
						  if (checkedUrl) checkedUrl = resolveUrl(checkedUrl);
						  return sharedUrlUtils.sameOriginCheck(location, checkedUrl);
						}

						function resolveUrl(url, doc) {
						  url = sharedUrlUtils.getURLString(url);

						  if (url && url.indexOf('//') === 0) {
						    // eslint-disable-next-line no-restricted-properties
						    var pageProtocol = getParsed().protocol;
						    url = pageProtocol + sharedUrlUtils.correctMultipleSlashes(url, pageProtocol);
						  } else url = sharedUrlUtils.correctMultipleSlashes(url);

						  return typeof document !== 'undefined' // @ts-ignore
						  ? urlResolver.resolve(url, doc || document) : new _nativeMethods.default.URL(url, get()).href; // eslint-disable-line no-restricted-properties
						}

						function get() {
						  var location = getLocation();
						  var parsedProxyUrl = sharedUrlUtils.parseProxyUrl(location);
						  return parsedProxyUrl ? parsedProxyUrl.destUrl : location;
						}

						function withHash(hash) {
						  var location = get(); // NOTE: Remove the previous hash if there is any.

						  location = location.replace(/(#.*)$/, '');
						  return location + hash;
						}

						function parseLocationThroughAnchor(url) {
						  // @ts-ignore
						  var resolver = urlResolver.getResolverElement(document); // eslint-disable-next-line no-restricted-properties

						  var destPort = sharedUrlUtils.parseUrl(url).port; // NOTE: IE browser adds the default port for the https protocol while resolving.

						  _nativeMethods.default.anchorHrefSetter.call(resolver, get());

						  var hostname = _nativeMethods.default.anchorHostnameGetter.call(resolver);

						  var pathname = _nativeMethods.default.anchorPathnameGetter.call(resolver); // NOTE: IE ignores the first '/' symbol in the pathname.


						  if (pathname.charAt(0) !== '/') pathname = '/' + pathname; // TODO: Describe default ports logic.

						  return {
						    protocol: _nativeMethods.default.anchorProtocolGetter.call(resolver),
						    // NOTE: Remove the default port.
						    port: destPort ? _nativeMethods.default.anchorPortGetter.call(resolver) : '',
						    hostname: hostname,
						    // NOTE: Remove the default port from the host.
						    host: destPort ? _nativeMethods.default.anchorHostGetter.call(resolver) : hostname,
						    pathname: pathname,
						    hash: resolver.hash,
						    search: _nativeMethods.default.anchorSearchGetter.call(resolver)
						  };
						}

						function parseLocationThroughURL(url) {
						  var parsedUrl = new _nativeMethods.default.URL(url);
						  /* eslint-disable no-restricted-properties */

						  return {
						    protocol: parsedUrl.protocol,
						    port: parsedUrl.port,
						    hostname: parsedUrl.hostname,
						    host: parsedUrl.host,
						    pathname: parsedUrl.pathname,
						    hash: parsedUrl.hash,
						    search: parsedUrl.search
						  };
						  /* eslint-enable no-restricted-properties */
						}

						function getParsed() {
						  var dest = get();
						  return typeof document !== 'undefined' ? parseLocationThroughAnchor(dest) : parseLocationThroughURL(dest);
						}

						function getOriginHeader() {
						  var parsedDest = getParsed(); // eslint-disable-next-line no-restricted-properties

						  return parsedDest.protocol === 'file:' ? get() : sharedUrlUtils.getDomain(parsedDest);
						}
					},
					"dom.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.instanceToString = instanceToString;
						exports.getActiveElement = getActiveElement;
						exports.getChildVisibleIndex = getChildVisibleIndex;
						exports.getIframeByElement = getIframeByElement;
						exports.getIframeLocation = getIframeLocation;
						exports.getFrameElement = getFrameElement;
						exports.getMapContainer = getMapContainer;
						exports.getParentWindowWithSrc = getParentWindowWithSrc;
						exports.getScrollbarSize = getScrollbarSize;
						exports.getSelectParent = getSelectParent;
						exports.getSelectVisibleChildren = getSelectVisibleChildren;
						exports.getTopSameDomainWindow = getTopSameDomainWindow;
						exports.find = find;
						exports.findDocument = findDocument;
						exports.isContentEditableElement = isContentEditableElement;
						exports.isCrossDomainIframe = isCrossDomainIframe;
						exports.isCrossDomainWindows = isCrossDomainWindows;
						exports.isDomElement = isDomElement;
						exports.getTagName = getTagName;
						exports.isElementInDocument = isElementInDocument;
						exports.isElementInIframe = isElementInIframe;
						exports.isHammerheadAttr = isHammerheadAttr;
						exports.isIframeElement = isIframeElement;
						exports.isIframeWithoutSrc = isIframeWithoutSrc;
						exports.isImgElement = isImgElement;
						exports.isInputElement = isInputElement;
						exports.isTitleElement = isTitleElement;
						exports.isButtonElement = isButtonElement;
						exports.isFieldSetElement = isFieldSetElement;
						exports.isOptGroupElement = isOptGroupElement;
						exports.isHtmlElement = isHtmlElement;
						exports.isBodyElement = isBodyElement;
						exports.isHeadElement = isHeadElement;
						exports.isHeadOrBodyElement = isHeadOrBodyElement;
						exports.isHeadOrBodyOrHtmlElement = isHeadOrBodyOrHtmlElement;
						exports.isBaseElement = isBaseElement;
						exports.isScriptElement = isScriptElement;
						exports.isStyleElement = isStyleElement;
						exports.isLabelElement = isLabelElement;
						exports.isTextAreaElement = isTextAreaElement;
						exports.isOptionElement = isOptionElement;
						exports.isRadioButtonElement = isRadioButtonElement;
						exports.isColorInputElement = isColorInputElement;
						exports.isCheckboxElement = isCheckboxElement;
						exports.isSelectElement = isSelectElement;
						exports.isFormElement = isFormElement;
						exports.isFileInput = isFileInput;
						exports.isInputWithNativeDialog = isInputWithNativeDialog;
						exports.isBodyElementWithChildren = isBodyElementWithChildren;
						exports.isMapElement = isMapElement;
						exports.isRenderedNode = isRenderedNode;
						exports.getTabIndex = getTabIndex;
						exports.isElementFocusable = isElementFocusable;
						exports.isShadowUIElement = isShadowUIElement;
						exports.isWindow = isWindow;
						exports.isDocument = isDocument;
						exports.isBlob = isBlob;
						exports.isLocation = isLocation;
						exports.isSVGElement = isSVGElement;
						exports.isSVGElementOrChild = isSVGElementOrChild;
						exports.isFetchHeaders = isFetchHeaders;
						exports.isFetchRequest = isFetchRequest;
						exports.isElementReadOnly = isElementReadOnly;
						exports.isTextEditableInput = isTextEditableInput;
						exports.isTextEditableElement = isTextEditableElement;
						exports.isTextEditableElementAndEditingAllowed = isTextEditableElementAndEditingAllowed;
						exports.isElementNode = isElementNode;
						exports.isTextNode = isTextNode;
						exports.isProcessingInstructionNode = isProcessingInstructionNode;
						exports.isCommentNode = isCommentNode;
						exports.isDocumentFragmentNode = isDocumentFragmentNode;
						exports.isShadowRoot = isShadowRoot;
						exports.isAnchorElement = isAnchorElement;
						exports.isTableElement = isTableElement;
						exports.isTableDataCellElement = isTableDataCellElement;
						exports.isWebSocket = isWebSocket;
						exports.isMessageEvent = isMessageEvent;
						exports.isPerformanceNavigationTiming = isPerformanceNavigationTiming;
						exports.isArrayBuffer = isArrayBuffer;
						exports.isArrayBufferView = isArrayBufferView;
						exports.isDataView = isDataView;
						exports.matches = matches;
						exports.closest = closest;
						exports.addClass = addClass;
						exports.removeClass = removeClass;
						exports.hasClass = hasClass;
						exports.parseDocumentCharset = parseDocumentCharset;
						exports.getParents = getParents;
						exports.findParent = findParent;
						exports.nodeListToArray = nodeListToArray;
						exports.getFileInputs = getFileInputs;
						exports.getIframes = getIframes;
						exports.getScripts = getScripts;
						exports.isNumberOrEmailInput = isNumberOrEmailInput;
						exports.isInputWithoutSelectionProperties = isInputWithoutSelectionProperties;

						var _internalAttributes = _interopRequireDefault(require("../../processing/dom/internal-attributes"));

						var _internalProperties = _interopRequireDefault(require("../../processing/dom/internal-properties"));

						var _className = _interopRequireDefault(require("../../shadow-ui/class-name"));

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						var urlUtils = _interopRequireWildcard(require("./url"));

						var _style = require("./style");

						var _destinationLocation = require("./destination-location");

						var _browser = require("./browser");

						var _querySelector = require("./query-selector");

						var _featureDetection = require("./feature-detection");

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var scrollbarSize = 0;
						var NATIVE_MAP_ELEMENT_STRINGS = ['[object HTMLMapElement]', '[object HTMLAreaElement]'];
						var WINDOW_IS_UNDEFINED = typeof window === 'undefined';
						var NATIVE_WINDOW_STR = WINDOW_IS_UNDEFINED ? '' : instanceToString(window);
						var IS_DOCUMENT_RE = /^\[object .*?Document]$/i;
						var IS_PROCESSING_INSTRUCTION_RE = /^\[object .*?ProcessingInstruction]$/i;
						var IS_SVG_ELEMENT_RE = /^\[object SVG\w+?Element]$/i;
						var IS_HTML_ELEMENT_RE = /^\[object HTML.*?Element]$/i;
						var IS_ARRAY_BUFFER_RE = /^\[object ArrayBuffer]$/i;
						var IS_DATA_VIEW_RE = /^\[object DataView]$/i;
						var NATIVE_TABLE_CELL_STR = WINDOW_IS_UNDEFINED ? '' : instanceToString(_nativeMethods.default.createElement.call(document, 'td'));
						var ELEMENT_NODE_TYPE = WINDOW_IS_UNDEFINED ? -1 : Node.ELEMENT_NODE;
						var NOT_CONTENT_EDITABLE_ELEMENTS_RE = /^(select|option|applet|area|audio|canvas|datalist|keygen|map|meter|object|progress|source|track|video|img)$/;
						var INPUT_ELEMENTS_RE = /^(input|textarea|button)$/;
						var SCRIPT_OR_STYLE_RE = /^(script|style)$/i;
						var EDITABLE_INPUT_TYPES_RE = /^(email|number|password|search|tel|text|url)$/;
						var NUMBER_OR_EMAIL_INPUT_RE = /^(number|email)$/; // NOTE: input with 'file' type processed separately in 'UploadSandbox'

						var INPUT_WITH_NATIVE_DIALOG = /^(color|date|datetime-local|month|week)$/; // NOTE: We don't take into account the case of embedded contentEditable elements, and we
						// specify the contentEditable attribute for focusable elements.

						var FOCUSABLE_SELECTOR = 'input, select, textarea, button, body, iframe, [contenteditable="true"], [contenteditable=""], [tabIndex]';

						function isHidden(el) {
						  return el.offsetWidth <= 0 && el.offsetHeight <= 0;
						}

						function isAlwaysNotEditableElement(el) {
						  var tagName = getTagName(el);
						  return !!tagName && (NOT_CONTENT_EDITABLE_ELEMENTS_RE.test(tagName) || INPUT_ELEMENTS_RE.test(tagName));
						}

						function isLocationByProto(instance) {
						  var instanceCtor = null;

						  try {
						    // eslint-disable-next-line no-proto
						    instanceCtor = instance.__proto__;
						  } catch (e) {
						    // NOTE: Try to detect cross-domain window location.
						    // A cross-domain location has no the "assign" function in Safari and Chrome.
						    var shouldNotHaveAssign = _browser.isSafari || _browser.isChrome;
						    return instance.replace && (shouldNotHaveAssign || !!instance.assign);
						  }

						  if (!instanceCtor) return false;

						  var stringifiedInstanceCtor = _nativeMethods.default.objectToString.call(instanceCtor);

						  return stringifiedInstanceCtor === '[object LocationPrototype]' || stringifiedInstanceCtor === '[object Location]'; // NOTE: "iPhone" Chrome device emulation case (GH-2080)
						}

						function closestFallback(el, selector) {
						  while (el) {
						    if (matches(el, selector)) return el;
						    el = _nativeMethods.default.nodeParentNodeGetter.call(el);
						  }

						  return null;
						}

						function instanceToString(instance) {
						  if (!_featureDetection.instanceAndPrototypeToStringAreEqual) return _nativeMethods.default.objectToString.call(instance);
						  return instance && typeof instance === 'object' ? _nativeMethods.default.objectToString.call(_nativeMethods.default.objectGetPrototypeOf(instance)) : '';
						}

						function getActiveElement(currentDocument) {
						  // NOTE: Sometimes document.activeElement returns an empty object or null (IE11).
						  // https://github.com/DevExpress/testcafe-hammerhead/issues/768
						  var doc = currentDocument || document;

						  var activeElement = _nativeMethods.default.documentActiveElementGetter.call(doc);

						  var el = isDomElement(activeElement) ? activeElement : doc.body;

						  while (el && el.shadowRoot) {
						    // eslint-disable-next-line no-restricted-properties
						    var shadowEl = el.shadowRoot.activeElement;
						    if (!shadowEl) break;
						    el = shadowEl;
						  }

						  return el;
						}

						function getChildVisibleIndex(select, child) {
						  var childrenArray = getSelectVisibleChildren(select);
						  return childrenArray.indexOf(child);
						}

						function getIframeByElement(el) {
						  var elWindow = el[_internalProperties.default.processedContext];
						  return getFrameElement(elWindow);
						}

						function getIframeLocation(iframe) {
						  var documentLocation = null;

						  try {
						    // eslint-disable-next-line no-restricted-properties
						    documentLocation = _nativeMethods.default.contentDocumentGetter.call(iframe).location.href;
						  } catch (e) {
						    documentLocation = null;
						  }

						  var srcLocation = _nativeMethods.default.getAttribute.call(iframe, 'src' + _internalAttributes.default.storedAttrPostfix) || _nativeMethods.default.getAttribute.call(iframe, 'src') || _nativeMethods.default.iframeSrcGetter.call(iframe);

						  var parsedProxyDocumentLocation = documentLocation && urlUtils.isSupportedProtocol(documentLocation) && urlUtils.parseProxyUrl(documentLocation);
						  var parsedProxySrcLocation = srcLocation && urlUtils.isSupportedProtocol(srcLocation) && urlUtils.parseProxyUrl(srcLocation);
						  return {
						    documentLocation: parsedProxyDocumentLocation ? parsedProxyDocumentLocation.destUrl : documentLocation,
						    srcLocation: parsedProxySrcLocation ? parsedProxySrcLocation.destUrl : srcLocation
						  };
						}

						function getFrameElement(win) {
						  try {
						    return win.frameElement;
						  } catch (e) {
						    return null;
						  }
						}

						function getMapContainer(el) {
						  var closestMap = closest(el, 'map');

						  var closestMapName = _nativeMethods.default.getAttribute.call(closestMap, 'name');

						  var containerSelector = '[usemap="#' + closestMapName + '"]';
						  return _nativeMethods.default.querySelector.call(findDocument(el), containerSelector);
						}

						function getParentWindowWithSrc(window) {
						  var parent = window.parent;
						  var parentFrameElement = null;
						  if (window === window.top) return window;
						  if (parent === window.top || isCrossDomainWindows(window, parent)) return parent;

						  try {
						    parentFrameElement = parent.frameElement;
						  } catch (e) {
						    parentFrameElement = null;
						  }

						  if (parentFrameElement === null || !isIframeWithoutSrc(parentFrameElement)) return parent;
						  return getParentWindowWithSrc(parent);
						}

						function getScrollbarSize() {
						  if (!scrollbarSize) {
						    var scrollDiv = _nativeMethods.default.createElement.call(document, 'div');

						    scrollDiv.style.height = '100px';
						    scrollDiv.style.overflow = 'scroll';
						    scrollDiv.style.position = 'absolute';
						    scrollDiv.style.top = '-9999px';
						    scrollDiv.style.width = '100px';

						    _nativeMethods.default.appendChild.call(document.body, scrollDiv);

						    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
						    scrollbarSize = scrollbarWidth;

						    var parent = _nativeMethods.default.nodeParentNodeGetter.call(scrollDiv);

						    parent.removeChild(scrollDiv);
						  }

						  return scrollbarSize;
						}

						function getSelectParent(child) {
						  var parent = _nativeMethods.default.nodeParentNodeGetter.call(child);

						  return closest(parent, 'select');
						}

						function getSelectVisibleChildren(select) {
						  var children = _nativeMethods.default.elementQuerySelectorAll.call(select, 'optgroup, option');

						  var result = [];

						  var length = _nativeMethods.default.nodeListLengthGetter.call(children);

						  for (var i = 0; i < length; i++) {
						    var child = children[i]; // NOTE: Firefox does not display groups without a label and with an empty label.

						    var shouldAdd = _browser.isFirefox ? getTagName(child) !== 'optgroup' || child.label : true;
						    if (shouldAdd) result.push(child);
						  }

						  return result;
						}

						function getTopSameDomainWindow(window) {
						  var result = window;
						  var currentWindow = window.parent;
						  if (result === window.top) return result;

						  while (currentWindow) {
						    if (!isCrossDomainWindows(window, currentWindow)) {
						      var frameElement = getFrameElement(currentWindow);
						      if (!frameElement || !isIframeWithoutSrc(frameElement)) result = currentWindow;
						    }

						    currentWindow = currentWindow !== window.top ? currentWindow.parent : null;
						  }

						  return result;
						}

						function find(parent, selector, handler) {
						  var nodeList = (0, _querySelector.getNativeQuerySelectorAll)(parent).call(parent, selector);

						  if (handler) {
						    var length = _nativeMethods.default.nodeListLengthGetter.call(nodeList);

						    for (var i = 0; i < length; i++) {
						      handler(nodeList[i]);
						    }
						  }

						  return nodeList;
						}

						function findDocument(el) {
						  if (el.documentElement) return el;
						  if (el.ownerDocument && el.ownerDocument.defaultView) return el.ownerDocument;

						  var parent = isElementNode(el) && _nativeMethods.default.nodeParentNodeGetter.call(el);

						  return parent ? findDocument(parent) : document;
						}

						function isContentEditableElement(el) {
						  var isContentEditable = false;
						  var element = null;
						  if (isTextNode(el)) element = el.parentElement || _nativeMethods.default.nodeParentNodeGetter.call(el);else element = el;

						  if (element) {
						    isContentEditable = element.isContentEditable && !isAlwaysNotEditableElement(element);
						    return isRenderedNode(element) && (isContentEditable || findDocument(el).designMode === 'on');
						  }

						  return false;
						}

						function isCrossDomainIframe(iframe, bySrc) {
						  var iframeLocation = getIframeLocation(iframe);
						  if (!bySrc && iframeLocation.documentLocation === null) return true;
						  var currentLocation = bySrc ? iframeLocation.srcLocation : iframeLocation.documentLocation;
						  if (currentLocation && urlUtils.isSupportedProtocol(currentLocation)) return !(0, _destinationLocation.sameOriginCheck)(location.toString(), currentLocation);
						  return false;
						}

						function isCrossDomainWindows(window1, window2) {
						  try {
						    if (window1 === window2) return false;
						    var window1Location = window1.location.toString();
						    var window2Location = window2.location.toString();
						    if (!urlUtils.isSupportedProtocol(window1Location) || !urlUtils.isSupportedProtocol(window2Location)) return false;
						    return !(0, _destinationLocation.sameOriginCheck)(window1Location, window2Location);
						  } catch (e) {
						    return true;
						  }
						}

						function isDomElement(el) {
						  if (el instanceof _nativeMethods.default.elementClass) return true;
						  return el && IS_HTML_ELEMENT_RE.test(instanceToString(el)) && isElementNode(el) && el.tagName;
						}

						function getTagName(el) {
						  // NOTE: Check for tagName being a string, because it may be a function in an Angular app (T175340).
						  return el && typeof el.tagName === 'string' ? el.tagName.toLowerCase() : '';
						}

						function isElementInDocument(el, currentDocument) {
						  var doc = currentDocument || document;
						  return doc.documentElement ? doc.documentElement.contains(el) : false;
						}

						function isElementInIframe(el, currentDocument) {
						  var doc = currentDocument || findDocument(el);
						  return window.document !== doc;
						}

						function isHammerheadAttr(attr) {
						  return attr === _internalAttributes.default.focusPseudoClass || attr === _internalAttributes.default.hoverPseudoClass || attr.indexOf(_internalAttributes.default.storedAttrPostfix) !== -1;
						}

						function isIframeElement(el) {
						  return instanceToString(el) === '[object HTMLIFrameElement]';
						}

						function isIframeWithoutSrc(iframe) {
						  var iframeLocation = getIframeLocation(iframe);
						  var iframeSrcLocation = iframeLocation.srcLocation;
						  var iframeDocumentLocation = iframeLocation.documentLocation; // NOTE: is a cross-domain iframe

						  if (iframeDocumentLocation === null) return false; // NOTE: after 'document.write' or 'document.open' call for iframe with/without src
						  // we will process it as iframe without src

						  if (_nativeMethods.default.contentWindowGetter.call(iframe)[_internalProperties.default.documentWasCleaned]) return true;
						  var iframeDocumentLocationHaveSupportedProtocol = urlUtils.isSupportedProtocol(iframeDocumentLocation); // NOTE: When an iframe has an empty src attribute (<iframe src></iframe>) or has no src attribute (<iframe></iframe>),
						  // the iframe.src property is not empty but has different values in different browsers.
						  // Its document location is 'about:blank'. Therefore, we should check the src attribute.

						  if (!iframeDocumentLocationHaveSupportedProtocol && !_nativeMethods.default.getAttribute.call(iframe, 'src')) return true; // In Chrome, when an iframe with the src attribute is added to DOM,
						  // its documentLocation is set to "about:blank" until the iframe has been loaded.
						  // So, we should check srcLocation in this case.

						  if (iframeSrcLocation && urlUtils.isSupportedProtocol(iframeSrcLocation)) return false;
						  return !iframeDocumentLocationHaveSupportedProtocol;
						}

						function isImgElement(el) {
						  return instanceToString(el) === '[object HTMLImageElement]';
						}

						function isInputElement(el) {
						  return instanceToString(el) === '[object HTMLInputElement]';
						}

						function isTitleElement(el) {
						  return instanceToString(el) === '[object HTMLTitleElement]';
						}

						function isButtonElement(el) {
						  return instanceToString(el) === '[object HTMLButtonElement]';
						}

						function isFieldSetElement(el) {
						  return instanceToString(el) === '[object HTMLFieldSetElement]';
						}

						function isOptGroupElement(el) {
						  return instanceToString(el) === '[object HTMLOptGroupElement]';
						}

						function isHtmlElement(el) {
						  return instanceToString(el) === '[object HTMLHtmlElement]';
						}

						function isBodyElement(el) {
						  return instanceToString(el) === '[object HTMLBodyElement]';
						}

						function isHeadElement(el) {
						  return instanceToString(el) === '[object HTMLHeadElement]';
						}

						function isHeadOrBodyElement(el) {
						  var elString = instanceToString(el);
						  return elString === '[object HTMLHeadElement]' || elString === '[object HTMLBodyElement]';
						}

						function isHeadOrBodyOrHtmlElement(el) {
						  var elString = instanceToString(el);
						  return elString === '[object HTMLHeadElement]' || elString === '[object HTMLBodyElement]' || elString === '[object HTMLHtmlElement]';
						}

						function isBaseElement(el) {
						  return instanceToString(el) === '[object HTMLBaseElement]';
						}

						function isScriptElement(el) {
						  return instanceToString(el) === '[object HTMLScriptElement]';
						}

						function isStyleElement(el) {
						  return instanceToString(el) === '[object HTMLStyleElement]';
						}

						function isLabelElement(el) {
						  return instanceToString(el) === '[object HTMLLabelElement]';
						}

						function isTextAreaElement(el) {
						  return instanceToString(el) === '[object HTMLTextAreaElement]';
						}

						function isOptionElement(el) {
						  return instanceToString(el) === '[object HTMLOptionElement]';
						}

						function isRadioButtonElement(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'radio';
						}

						function isColorInputElement(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'color';
						}

						function isCheckboxElement(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'checkbox';
						}

						function isSelectElement(el) {
						  return instanceToString(el) === '[object HTMLSelectElement]';
						}

						function isFormElement(el) {
						  return instanceToString(el) === '[object HTMLFormElement]';
						}

						function isFileInput(el) {
						  return isInputElement(el) && el.type.toLowerCase() === 'file';
						}

						function isInputWithNativeDialog(el) {
						  return isInputElement(el) && INPUT_WITH_NATIVE_DIALOG.test(el.type.toLowerCase());
						}

						function isBodyElementWithChildren(el) {
						  return isBodyElement(el) && _nativeMethods.default.htmlCollectionLengthGetter.call(el.children);
						}

						function isMapElement(el) {
						  return NATIVE_MAP_ELEMENT_STRINGS.indexOf(instanceToString(el)) !== -1;
						}

						function isRenderedNode(node) {
						  return !(isProcessingInstructionNode(node) || isCommentNode(node) || SCRIPT_OR_STYLE_RE.test(node.nodeName));
						}

						function getTabIndex(el) {
						  // NOTE: we obtain the tabIndex value from an attribute because the el.tabIndex
						  // property returns -1 for some elements (e.g. for body) with no tabIndex assigned
						  var tabIndex = _nativeMethods.default.getAttribute.call(el, 'tabIndex');

						  tabIndex = parseInt(tabIndex, 10);
						  return isNaN(tabIndex) ? null : tabIndex;
						}

						function isElementFocusable(el) {
						  if (!el) return false;
						  var tabIndex = getTabIndex(el);
						  var isDisabledElement = matches(el, ':disabled');
						  var isInvisibleElement = (0, _style.get)(el, 'visibility') === 'hidden';
						  var isNotDisplayedElement = (0, _style.get)(el, 'display') === 'none';
						  var isHiddenElement = _browser.isWebKit ? isHidden(el) && !isOptionElement(el) : isHidden(el);
						  if (isDisabledElement || isInvisibleElement || isNotDisplayedElement || isHiddenElement) return false;
						  if (isOptionElement(el) && _browser.isIE) return false;

						  if (isAnchorElement(el)) {
						    if (tabIndex !== null) return true;
						    return matches(el, 'a[href]');
						  }

						  if (isTableDataCellElement(el) && _browser.isIE) return true;
						  return matches(el, FOCUSABLE_SELECTOR) || tabIndex !== null;
						}

						function isShadowUIElement(element) {
						  // @ts-ignore
						  return !!element[_internalProperties.default.shadowUIElement];
						}

						function isWindow(instance) {
						  if (instance instanceof _nativeMethods.default.windowClass) return true;

						  try {
						    // NOTE: The instanceToString call result has a strange values for the MessageEvent.target property:
						    // * [object DispHTMLWindow2] for IE11
						    // * [object Object] for MSEdge.
						    if ((_browser.isIE || _browser.isMSEdge) && instance && instance === instance.window) instance = instance.window;
						    return instance && instance.toString && NATIVE_WINDOW_STR === instanceToString(instance);
						  } catch (e) {
						    try {
						      // NOTE: If a cross-domain object has the 'top' field, this object is a window
						      // (not a document or location).
						      return !!instance.top;
						    } catch (x) {
						      return false;
						    }
						  }
						}

						function isDocument(instance) {
						  if (instance instanceof _nativeMethods.default.documentClass) return true;

						  try {
						    return instance && IS_DOCUMENT_RE.test(instanceToString(instance));
						  } catch (e) {
						    // NOTE: For cross-domain objects (windows, documents or locations), we return false because
						    // it's impossible to work with them in any case.
						    return false;
						  }
						}

						function isBlob(instance) {
						  return instance && instanceToString(instance) === '[object Blob]';
						}

						function isLocation(instance) {
						  if (!instance) return false;
						  if (_browser.isIE || _browser.isSafari || _browser.isChrome) return isLocationByProto(instance);
						  return instance instanceof _nativeMethods.default.locationClass || _nativeMethods.default.objectToString.call(instance) === '[object Location]';
						}

						function isSVGElement(instance) {
						  if (instance instanceof _nativeMethods.default.svgElementClass) return true;
						  return instance && IS_SVG_ELEMENT_RE.test(instanceToString(instance));
						}

						function isSVGElementOrChild(el) {
						  return !!closest(el, 'svg');
						}

						function isFetchHeaders(instance) {
						  if (_nativeMethods.default.Headers && instance instanceof _nativeMethods.default.Headers) return true;
						  return instance && instanceToString(instance) === '[object Headers]';
						}

						function isFetchRequest(instance) {
						  if (_nativeMethods.default.Request && instance instanceof _nativeMethods.default.Request) return true;
						  return instance && instanceToString(instance) === '[object Request]';
						}

						function isElementReadOnly(el) {
						  return el.readOnly || el.getAttribute('readonly') === 'readonly';
						}

						function isTextEditableInput(el) {
						  var attrType = el.getAttribute('type');
						  return isInputElement(el) && attrType ? EDITABLE_INPUT_TYPES_RE.test(attrType) : EDITABLE_INPUT_TYPES_RE.test(el.type);
						}

						function isTextEditableElement(el) {
						  return isTextEditableInput(el) || isTextAreaElement(el);
						}

						function isTextEditableElementAndEditingAllowed(el) {
						  return isTextEditableElement(el) && !isElementReadOnly(el);
						}

						function isElementNode(node) {
						  return node && node.nodeType === ELEMENT_NODE_TYPE;
						}

						function isTextNode(node) {
						  return instanceToString(node) === '[object Text]';
						}

						function isProcessingInstructionNode(node) {
						  return IS_PROCESSING_INSTRUCTION_RE.test(instanceToString(node));
						}

						function isCommentNode(node) {
						  return instanceToString(node) === '[object Comment]';
						}

						function isDocumentFragmentNode(node) {
						  return instanceToString(node) === '[object DocumentFragment]';
						}

						function isShadowRoot(root) {
						  return instanceToString(root) === '[object ShadowRoot]';
						}

						function isAnchorElement(el) {
						  return instanceToString(el) === '[object HTMLAnchorElement]';
						}

						function isTableElement(el) {
						  return instanceToString(el) === '[object HTMLTableElement]';
						}

						function isTableDataCellElement(el) {
						  return instanceToString(el) === NATIVE_TABLE_CELL_STR;
						}

						function isWebSocket(ws) {
						  return instanceToString(ws) === '[object WebSocket]';
						}

						function isMessageEvent(e) {
						  return instanceToString(e) === '[object MessageEvent]';
						}

						function isPerformanceNavigationTiming(entry) {
						  return instanceToString(entry) === '[object PerformanceNavigationTiming]';
						}

						function isArrayBuffer(data) {
						  if (data instanceof _nativeMethods.default.ArrayBuffer) return true;
						  return data && IS_ARRAY_BUFFER_RE.test(instanceToString(data));
						}

						function isArrayBufferView(data) {
						  return data && _nativeMethods.default.arrayBufferIsView(data);
						}

						function isDataView(data) {
						  if (data instanceof _nativeMethods.default.DataView) return true;
						  return data && IS_DATA_VIEW_RE.test(instanceToString(data));
						}

						function matches(el, selector) {
						  if (!isElementNode(el)) return false;
						  return _nativeMethods.default.matches.call(el, selector);
						}

						function closest(el, selector) {
						  if (!isElementNode(el)) return null;
						  if (_nativeMethods.default.closest) return _nativeMethods.default.closest.call(el, selector);
						  return closestFallback(el, selector);
						}

						function addClass(el, className) {
						  if (!el) return;
						  var classNames = className.split(/\s+/);

						  for (var _i2 = 0; _i2 < classNames.length; _i2++) {
						    var currentClassName = classNames[_i2];

						    _nativeMethods.default.tokenListAdd.call(_nativeMethods.default.elementClassListGetter.call(el), currentClassName);
						  }
						}

						function removeClass(el, className) {
						  if (!el) return;
						  var classNames = className.split(/\s+/);

						  for (var _i4 = 0; _i4 < classNames.length; _i4++) {
						    var currentClassName = classNames[_i4];

						    _nativeMethods.default.tokenListRemove.call(_nativeMethods.default.elementClassListGetter.call(el), currentClassName);
						  }
						}

						function hasClass(el, className) {
						  if (!el) return false;
						  return _nativeMethods.default.tokenListContains.call(_nativeMethods.default.elementClassListGetter.call(el), className);
						}

						function parseDocumentCharset() {
						  var metaCharset = _nativeMethods.default.querySelector.call(document, '.' + _className.default.charset);

						  return metaCharset && metaCharset.getAttribute('charset');
						}

						function getParents(el, selector) {
						  var parents = [];
						  var parent = getParent(el);

						  while (parent) {
						    if (!selector && isElementNode(parent) || selector && matches(parent, selector)) parents.push(parent);
						    parent = getParent(parent);
						  }

						  return parents;
						}

						function getParent(el) {
						  el = el.assignedSlot || el; // eslint-disable-next-line no-restricted-properties

						  return _nativeMethods.default.nodeParentNodeGetter.call(el) || el.host;
						}

						function findParent(node, includeSelf, predicate) {
						  if (includeSelf === void 0) {
						    includeSelf = false;
						  }

						  if (!includeSelf) node = _nativeMethods.default.nodeParentNodeGetter.call(node);

						  while (node) {
						    if (typeof predicate !== 'function' || predicate(node)) return node;
						    node = _nativeMethods.default.nodeParentNodeGetter.call(node);
						  }

						  return null;
						}

						function nodeListToArray(nodeList) {
						  var result = [];

						  var length = _nativeMethods.default.nodeListLengthGetter.call(nodeList);

						  for (var i = 0; i < length; i++) {
						    result.push(nodeList[i]);
						  }

						  return result;
						}

						function getFileInputs(el) {
						  return isFileInput(el) ? [el] : nodeListToArray((0, _querySelector.getNativeQuerySelectorAll)(el).call(el, 'input[type=file]'));
						}

						function getIframes(el) {
						  return isIframeElement(el) ? [el] : nodeListToArray((0, _querySelector.getNativeQuerySelectorAll)(el).call(el, 'iframe,frame'));
						}

						function getScripts(el) {
						  return isScriptElement(el) ? [el] : nodeListToArray((0, _querySelector.getNativeQuerySelectorAll)(el).call(el, 'script'));
						}

						function isNumberOrEmailInput(el) {
						  return isInputElement(el) && NUMBER_OR_EMAIL_INPUT_RE.test(el.type);
						}

						function isInputWithoutSelectionProperties(el) {
						  if (!isNumberOrEmailInput(el)) return false;
						  var hasSelectionProperties = typeof el.selectionStart === 'number' && typeof el.selectionEnd === 'number';
						  return !hasSelectionProperties;
						}
					},
					"event-emitter.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						var _browser = require("./browser");

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var EventEmitter = /*#__PURE__*/function () {
						  function EventEmitter() {
						    this.eventsListeners = _nativeMethods.default.objectCreate(null);
						  }

						  var _proto = EventEmitter.prototype;

						  _proto.emit = function emit(evt) {
						    var listeners = this.eventsListeners[evt];
						    if (!listeners) return;
						    var index = 0;

						    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						      args[_key - 1] = arguments[_key];
						    }

						    while (listeners[index]) {
						      // HACK: For IE: after calling document.write, the IFrameSandbox event handler throws the
						      // 'Can't execute code from a freed script' exception because the document has been
						      // recreated.
						      if (_browser.isIE) {
						        try {
						          listeners[index].toString();
						        } catch (e) {
						          _nativeMethods.default.arraySplice.call(listeners, index, 1);

						          continue;
						        }
						      }

						      listeners[index++].apply(this, args);
						    }
						  };

						  _proto.off = function off(evt, listener) {
						    var listeners = this.eventsListeners[evt];
						    if (!listeners) return;
						    this.eventsListeners[evt] = _nativeMethods.default.arrayFilter.call(listeners, function (currentListener) {
						      return currentListener !== listener;
						    });
						  };

						  _proto.on = function on(evt, listener) {
						    this.eventsListeners[evt] = this.eventsListeners[evt] || [];
						    if (this.eventsListeners[evt].indexOf(listener) === -1) this.eventsListeners[evt].push(listener);
						    return listener;
						  };

						  return EventEmitter;
						}();

						exports.default = EventEmitter;
						module.exports = exports.default;
					},
					"feature-detection.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.getElementsByNameReturnsHTMLCollection = exports.attrGetNamedItemIsNotEnumerable = exports.hasDataTransfer = exports.isTouchDevice = exports.hasTouchPoints = exports.hasTouchEvents = exports.instanceAndPrototypeToStringAreEqual = exports.emptyActionAttrFallbacksToTheLocation = void 0;

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						var browserUtils = _interopRequireWildcard(require("./browser"));

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var emptyActionAttrFallbacksToTheLocation = false;
						exports.emptyActionAttrFallbacksToTheLocation = emptyActionAttrFallbacksToTheLocation;
						var instanceAndPrototypeToStringAreEqual = false;
						exports.instanceAndPrototypeToStringAreEqual = instanceAndPrototypeToStringAreEqual;
						var hasTouchEvents = false;
						exports.hasTouchEvents = hasTouchEvents;
						var hasTouchPoints = false;
						exports.hasTouchPoints = hasTouchPoints;
						var isTouchDevice = false;
						exports.isTouchDevice = isTouchDevice;
						var hasDataTransfer = false;
						exports.hasDataTransfer = hasDataTransfer;
						var attrGetNamedItemIsNotEnumerable = false;
						exports.attrGetNamedItemIsNotEnumerable = attrGetNamedItemIsNotEnumerable;
						var getElementsByNameReturnsHTMLCollection = false;
						exports.getElementsByNameReturnsHTMLCollection = getElementsByNameReturnsHTMLCollection;

						if (_nativeMethods.default.createElement) {
						  var form = _nativeMethods.default.createElement.call(document, 'form');

						  var elements = _nativeMethods.default.getElementsByName.call(document, ''); // NOTE: In some browsers, elements without the url attribute return the location url
						  // when accessing this attribute directly. See form.action in Edge 25 as an example.


						  exports.emptyActionAttrFallbacksToTheLocation = emptyActionAttrFallbacksToTheLocation = _nativeMethods.default.formActionGetter.call(form) === window.location.toString(); // NOTE: In Chrome, toString(window) equals '[object Window]' and toString(Window.prototype) equals '[object Blob]',
						  // this condition is also satisfied for Blob, Document, XMLHttpRequest, etc

						  exports.instanceAndPrototypeToStringAreEqual = instanceAndPrototypeToStringAreEqual = _nativeMethods.default.objectToString.call(window) === _nativeMethods.default.objectToString.call(Window.prototype);
						  exports.hasTouchEvents = hasTouchEvents = 'ontouchstart' in window; // NOTE: We need to check touch points only for IE, because it has PointerEvent and MSPointerEvent (IE10, IE11)
						  // instead of TouchEvent (T109295).

						  exports.hasTouchPoints = hasTouchPoints = browserUtils.isIE && (navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0);
						  exports.isTouchDevice = isTouchDevice = (browserUtils.isMobile || browserUtils.isTablet) && hasTouchEvents; // @ts-ignore

						  exports.hasDataTransfer = hasDataTransfer = !!window.DataTransfer; // NOTE: In the Edge 17, the getNamedItem method of attributes object is not enumerable

						  exports.attrGetNamedItemIsNotEnumerable = attrGetNamedItemIsNotEnumerable = _nativeMethods.default.objectGetOwnPropertyDescriptor // @ts-ignore
						  .call(window.Object, NamedNodeMap.prototype, 'getNamedItem'); // Both IE and Edge return an HTMLCollection, not a NodeList
						  // @ts-ignore

						  exports.getElementsByNameReturnsHTMLCollection = getElementsByNameReturnsHTMLCollection = _nativeMethods.default.objectGetPrototypeOf.call(window.Object, elements) === _nativeMethods.default.HTMLCollection.prototype;
						}
					},
					"global-context-info.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = getGlobalContextInfo;

						function getGlobalContextInfo() {
						  var isInWorker = typeof window === 'undefined' && typeof self === 'object';
						  return {
						    isInWorker: isInWorker,
						    global: isInWorker ? self : window
						  };
						}

						module.exports = exports.default;
					},
					"headers.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.transformHeaderNameToBuiltin = transformHeaderNameToBuiltin;
						exports.transformHeaderNameToInternal = transformHeaderNameToInternal;

						var _builtinHeaderNames = _interopRequireDefault(require("../../request-pipeline/builtin-header-names"));

						var _internalHeaderNames = _interopRequireDefault(require("../../request-pipeline/internal-header-names"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var BUILTIN_TO_INTERNAL_HEADERS_MAP = new Map();
						var INTERNAL_TO_BUILTIN_HEADERS_MAP = new Map();
						BUILTIN_TO_INTERNAL_HEADERS_MAP.set(_builtinHeaderNames.default.authorization, _internalHeaderNames.default.authorization);
						BUILTIN_TO_INTERNAL_HEADERS_MAP.set(_builtinHeaderNames.default.proxyAuthorization, _internalHeaderNames.default.proxyAuthorization);
						BUILTIN_TO_INTERNAL_HEADERS_MAP.set(_builtinHeaderNames.default.wwwAuthenticate, _internalHeaderNames.default.wwwAuthenticate);
						BUILTIN_TO_INTERNAL_HEADERS_MAP.set(_builtinHeaderNames.default.proxyAuthenticate, _internalHeaderNames.default.proxyAuthenticate);
						INTERNAL_TO_BUILTIN_HEADERS_MAP.set(_internalHeaderNames.default.authorization, _builtinHeaderNames.default.authorization);
						INTERNAL_TO_BUILTIN_HEADERS_MAP.set(_internalHeaderNames.default.proxyAuthorization, _builtinHeaderNames.default.proxyAuthorization);
						INTERNAL_TO_BUILTIN_HEADERS_MAP.set(_internalHeaderNames.default.wwwAuthenticate, _builtinHeaderNames.default.wwwAuthenticate);
						INTERNAL_TO_BUILTIN_HEADERS_MAP.set(_internalHeaderNames.default.proxyAuthenticate, _builtinHeaderNames.default.proxyAuthenticate);

						function transformHeaderNameToBuiltin(headerName) {
						  if (typeof headerName === 'string') {
						    headerName = headerName.toLowerCase();
						    return INTERNAL_TO_BUILTIN_HEADERS_MAP.get(headerName) || headerName;
						  }

						  return headerName;
						}

						function transformHeaderNameToInternal(headerName) {
						  if (typeof headerName === 'string') {
						    headerName = headerName.toLowerCase();
						    return BUILTIN_TO_INTERNAL_HEADERS_MAP.get(headerName) || headerName;
						  }

						  return headerName;
						}
					},
					"property-overriding.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.createOverriddenDescriptor = createOverriddenDescriptor;
						exports.overrideDescriptor = overrideDescriptor;

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function replaceNativeAccessor(descriptor, accessorName, newAccessor) {
						  if (newAccessor && descriptor[accessorName]) {
						    var stringifiedNativeAccessor = descriptor[accessorName].toString();

						    newAccessor.toString = function () {
						      return stringifiedNativeAccessor;
						    };
						  }

						  descriptor[accessorName] = newAccessor;
						}

						function createOverriddenDescriptor(obj, prop, _ref) {
						  var getter = _ref.getter,
						      setter = _ref.setter,
						      value = _ref.value;

						  var descriptor = _nativeMethods.default.objectGetOwnPropertyDescriptor(obj, prop);

						  if ((getter || setter) && value) throw new Error('Cannot both specify accessors and a value or writable attribute.');

						  if (value) {
						    if (!_nativeMethods.default.objectHasOwnProperty.call(descriptor, 'writable')) {
						      descriptor.writable = !!descriptor.set;
						      delete descriptor.get;
						      delete descriptor.set;
						    }

						    descriptor.value = value; // eslint-disable-line no-restricted-properties
						  } else {
						    if (_nativeMethods.default.objectHasOwnProperty.call(descriptor, 'writable')) {
						      delete descriptor.value; // eslint-disable-line no-restricted-properties

						      delete descriptor.writable;
						    }

						    if (getter !== null) replaceNativeAccessor(descriptor, 'get', getter);
						    if (setter !== null) replaceNativeAccessor(descriptor, 'set', setter);
						  }

						  return descriptor;
						}

						function overrideDescriptor(obj, prop, propertyAccessors) {
						  var descriptor = createOverriddenDescriptor(obj, prop, propertyAccessors);

						  _nativeMethods.default.objectDefineProperty(obj, prop, descriptor);
						}
					},
					"query-selector.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.getNativeQuerySelector = getNativeQuerySelector;
						exports.getNativeQuerySelectorAll = getNativeQuerySelectorAll;

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						var _dom = require("./dom");

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function getNativeQuerySelector(el) {
						  if ((0, _dom.isDomElement)(el)) return _nativeMethods.default.elementQuerySelector;
						  return (0, _dom.isDocumentFragmentNode)(el) || (0, _dom.isShadowRoot)(el) ? _nativeMethods.default.documentFragmentQuerySelector : _nativeMethods.default.querySelector;
						}

						function getNativeQuerySelectorAll(el) {
						  // NOTE: Do not return the isDocument function instead of the isDomElement
						  // it leads to the `Invalid calling object` error in some cases in IE11 (GH-1846)
						  if ((0, _dom.isDomElement)(el)) return _nativeMethods.default.elementQuerySelectorAll;
						  return (0, _dom.isDocumentFragmentNode)(el) || (0, _dom.isShadowRoot)(el) ? _nativeMethods.default.documentFragmentQuerySelectorAll : _nativeMethods.default.querySelectorAll;
						}
					},
					"style.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.get = get;
						exports.set = set;
						exports.getBordersWidth = getBordersWidth;
						exports.getComputedStyle = getComputedStyle;
						exports.getElementMargin = getElementMargin;
						exports.getElementPadding = getElementPadding;
						exports.getElementScroll = getElementScroll;
						exports.getWidth = getWidth;
						exports.getHeight = getHeight;
						exports.getInnerWidth = getInnerWidth;
						exports.getInnerHeight = getInnerHeight;
						exports.getOptionHeight = getOptionHeight;
						exports.getSelectElementSize = getSelectElementSize;
						exports.isVisibleChild = isVisibleChild;
						exports.getScrollLeft = getScrollLeft;
						exports.getScrollTop = getScrollTop;
						exports.setScrollLeft = setScrollLeft;
						exports.setScrollTop = setScrollTop;
						exports.getOffsetParent = getOffsetParent;
						exports.getOffset = getOffset;
						exports.isElementVisible = isElementVisible;
						exports.isElementInInvisibleIframe = isElementInInvisibleIframe;

						var domUtils = _interopRequireWildcard(require("./dom"));

						var browserUtils = _interopRequireWildcard(require("./browser"));

						var featureDetection = _interopRequireWildcard(require("./feature-detection"));

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						// NOTE: For Chrome.
						var MIN_SELECT_SIZE_VALUE = 4;

						function getIntValue(value) {
						  value = value || '';
						  var parsedValue = parseInt(value.replace('px', ''), 10);
						  return isNaN(parsedValue) ? 0 : parsedValue;
						}

						function get(el, property, doc, win) {
						  el = el.documentElement || el;
						  var computedStyle = getComputedStyle(el, doc, win);
						  return computedStyle && computedStyle[property];
						}

						function set(el, property, value) {
						  el = el.documentElement || el;
						  el.style[property] = value;
						}

						function getBordersWidth(el) {
						  return {
						    bottom: getIntValue(get(el, 'borderBottomWidth')),
						    left: getIntValue(get(el, 'borderLeftWidth')),
						    right: getIntValue(get(el, 'borderRightWidth')),
						    top: getIntValue(get(el, 'borderTopWidth'))
						  };
						}

						function getComputedStyle(el, doc, win) {
						  // NOTE: In Firefox, after calling the 'document.write' function for nested iframes with html src value
						  // document.defaultView equals 'null'. But 'window.document' equals 'document'.
						  // This is why, we are forced to calculate the targetWindow instead of use document.defaultView.
						  doc = doc || document;
						  win = win || window;
						  var targetWin = doc.defaultView || win;
						  return targetWin.getComputedStyle(el, null);
						}

						function getElementMargin(el) {
						  return {
						    bottom: getIntValue(get(el, 'marginBottom')),
						    left: getIntValue(get(el, 'marginLeft')),
						    right: getIntValue(get(el, 'marginRight')),
						    top: getIntValue(get(el, 'marginTop'))
						  };
						}

						function getElementPadding(el) {
						  return {
						    bottom: getIntValue(get(el, 'paddingBottom')),
						    left: getIntValue(get(el, 'paddingLeft')),
						    right: getIntValue(get(el, 'paddingRight')),
						    top: getIntValue(get(el, 'paddingTop'))
						  };
						}

						function getElementScroll(el) {
						  var isHtmlElement = domUtils.isHtmlElement(el);
						  var currentWindow = window;

						  if (isHtmlElement && domUtils.isElementInIframe(el)) {
						    var currentIframe = domUtils.getIframeByElement(el);
						    if (currentIframe) currentWindow = _nativeMethods.default.contentWindowGetter.call(currentIframe);
						  }

						  var targetEl = isHtmlElement ? currentWindow : el;
						  return {
						    left: getScrollLeft(targetEl),
						    top: getScrollTop(targetEl)
						  };
						}

						function getWidth(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientWidth;

						  if (domUtils.isDocument(el)) {
						    var doc = el.documentElement;
						    var clientProp = 'clientWidth';
						    var scrollProp = 'scrollWidth';
						    var offsetProp = 'offsetWidth';
						    if (doc[clientProp] >= doc[scrollProp]) return doc[clientProp];
						    return Math.max(el.body[scrollProp], doc[scrollProp], el.body[offsetProp], doc[offsetProp]);
						  }

						  var value = el.offsetWidth;
						  value -= getIntValue(get(el, 'paddingLeft'));
						  value -= getIntValue(get(el, 'paddingRight'));
						  value -= getIntValue(get(el, 'borderLeftWidth'));
						  value -= getIntValue(get(el, 'borderRightWidth'));
						  return value;
						}

						function getHeight(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientHeight;

						  if (domUtils.isDocument(el)) {
						    var doc = el.documentElement;
						    var clientProp = 'clientHeight';
						    var scrollProp = 'scrollHeight';
						    var offsetProp = 'offsetHeight';
						    if (doc[clientProp] >= doc[scrollProp]) return doc[clientProp];
						    return Math.max(el.body[scrollProp], doc[scrollProp], el.body[offsetProp], doc[offsetProp]);
						  }

						  var value = el.offsetHeight;
						  value -= getIntValue(get(el, 'paddingTop'));
						  value -= getIntValue(get(el, 'paddingBottom'));
						  value -= getIntValue(get(el, 'borderTopWidth'));
						  value -= getIntValue(get(el, 'borderBottomWidth'));
						  return value;
						}

						function getInnerWidth(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientWidth;
						  if (domUtils.isDocument(el)) return el.documentElement.clientWidth;
						  var value = el.offsetWidth;
						  value -= getIntValue(get(el, 'borderLeftWidth'));
						  value -= getIntValue(get(el, 'borderRightWidth'));
						  return value;
						}

						function getInnerHeight(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.document.documentElement.clientHeight;
						  if (domUtils.isDocument(el)) return el.documentElement.clientHeight;
						  var value = el.offsetHeight;
						  value -= getIntValue(get(el, 'borderTopWidth'));
						  value -= getIntValue(get(el, 'borderBottomWidth'));
						  return value;
						}

						function getOptionHeight(select) {
						  var realSizeValue = getSelectElementSize(select);
						  var selectPadding = getElementPadding(select);
						  var selectScrollHeight = select.scrollHeight - (selectPadding.top + selectPadding.bottom);
						  var childrenCount = domUtils.getSelectVisibleChildren(select).length;
						  if (realSizeValue === 1) return getHeight(select);
						  return browserUtils.isIE && realSizeValue > childrenCount ? Math.round(selectScrollHeight / childrenCount) : Math.round(selectScrollHeight / Math.max(childrenCount, realSizeValue));
						}

						function getSelectElementSize(select) {
						  // NOTE: iOS and Android ignore 'size' and 'multiple' attributes,
						  // all select elements behave like a select with size=1.
						  if (browserUtils.isSafari && featureDetection.hasTouchEvents || browserUtils.isAndroid) return 1;

						  var sizeAttr = _nativeMethods.default.getAttribute.call(select, 'size');

						  var multipleAttr = _nativeMethods.default.getAttribute.call(select, 'multiple');

						  var size = !sizeAttr ? 1 : parseInt(sizeAttr, 10);
						  if (multipleAttr && (!sizeAttr || size < 1)) size = MIN_SELECT_SIZE_VALUE;
						  return size;
						}

						function isVisibleChild(el) {
						  var select = domUtils.getSelectParent(el);
						  var tagName = domUtils.getTagName(el);
						  return domUtils.isSelectElement(select) && getSelectElementSize(select) > 1 && (tagName === 'option' || tagName === 'optgroup') && ( // NOTE: Firefox does not display groups without a label or with an empty label.
						  !browserUtils.isFirefox || el.label);
						}

						function getScrollLeft(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.pageXOffset;
						  if (domUtils.isDocument(el)) return el.defaultView.pageXOffset;
						  return el.scrollLeft;
						}

						function getScrollTop(el) {
						  if (!el) return null;
						  if (domUtils.isWindow(el)) return el.pageYOffset;
						  if (domUtils.isDocument(el)) return el.defaultView.pageYOffset;
						  return el.scrollTop;
						}

						function setScrollLeft(el, value) {
						  if (!el) return;

						  if (domUtils.isWindow(el) || domUtils.isDocument(el)) {
						    var win = domUtils.findDocument(el).defaultView;
						    var scrollTop = getScrollTop(el);

						    _nativeMethods.default.scrollTo.call(win, value, scrollTop);
						  } else el.scrollLeft = value;
						}

						function setScrollTop(el, value) {
						  if (!el) return;

						  if (domUtils.isWindow(el) || domUtils.isDocument(el)) {
						    var win = domUtils.findDocument(el).defaultView;
						    var scrollLeft = getScrollLeft(el);

						    _nativeMethods.default.scrollTo.call(win, scrollLeft, value);
						  } else el.scrollTop = value;
						}

						function getOffsetParent(el) {
						  if (el) {
						    var offsetParent = el.offsetParent || document.body;

						    while (offsetParent && !/^(?:body|html)$/i.test(offsetParent.nodeName) && get(offsetParent, 'position') === 'static') {
						      offsetParent = offsetParent.offsetParent;
						    }

						    return offsetParent;
						  }

						  return void 0;
						}

						function getOffset(el) {
						  if (!el || domUtils.isWindow(el) || domUtils.isDocument(el)) return null;
						  var clientRect = el.getBoundingClientRect(); // NOTE: A detached node or documentElement.

						  var doc = el.ownerDocument;
						  var docElement = doc.documentElement;

						  if (!docElement.contains(el) || el === docElement) {
						    return {
						      top: clientRect.top,
						      left: clientRect.left
						    };
						  }

						  var win = doc.defaultView;
						  var clientTop = docElement.clientTop || doc.body.clientTop || 0;
						  var clientLeft = docElement.clientLeft || doc.body.clientLeft || 0;
						  var scrollTop = win.pageYOffset || docElement.scrollTop || doc.body.scrollTop;
						  var scrollLeft = win.pageXOffset || docElement.scrollLeft || doc.body.scrollLeft;
						  clientRect = el.getBoundingClientRect();
						  return {
						    top: clientRect.top + scrollTop - clientTop,
						    left: clientRect.left + scrollLeft - clientLeft
						  };
						}

						function isElementVisible(el, doc) {
						  if (!domUtils.isElementInDocument(el, doc)) return false;

						  while (el) {
						    if (get(el, 'display', doc) === 'none' || get(el, 'visibility', doc) === 'hidden') return false;
						    el = _nativeMethods.default.nodeParentNodeGetter.call(el);
						  }

						  return true;
						}

						function isElementInInvisibleIframe(el) {
						  var frameElement = domUtils.getIframeByElement(el);
						  return frameElement && !isElementVisible(frameElement, domUtils.findDocument(frameElement));
						}
					},
					"url-resolver.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;

						var _nativeMethods = _interopRequireDefault(require("../sandbox/native-methods"));

						var destLocation = _interopRequireWildcard(require("../utils/destination-location"));

						var _url = require("../../utils/url");

						var _dom = require("./dom");

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var DOCUMENT_URL_RESOLVER = 'hammerhead|document-url-resolver';
						var _default = {
						  _createResolver: function _createResolver(doc) {
						    var htmlDocument = _nativeMethods.default.createHTMLDocument.call(doc.implementation, 'title');

						    var a = _nativeMethods.default.createElement.call(htmlDocument, 'a');

						    var base = _nativeMethods.default.createElement.call(htmlDocument, 'base');

						    _nativeMethods.default.appendChild.call(htmlDocument.body, a);

						    _nativeMethods.default.appendChild.call(htmlDocument.head, base);

						    return htmlDocument;
						  },
						  _getResolver: function _getResolver(doc) {
						    // NOTE: Once a document is recreated (document.open, document.write is called), nativeMethods will be refreshed.
						    // If we call urlResolve.updateBase after this,
						    // we will use native methods from an actual document.
						    // However, a document that contains an element for url resolving is created using a previous version of nativeMethods.
						    if (!doc[DOCUMENT_URL_RESOLVER]) {
						      _nativeMethods.default.objectDefineProperty(doc, DOCUMENT_URL_RESOLVER, {
						        value: this._createResolver(doc),
						        writable: true
						      });
						    }

						    return doc[DOCUMENT_URL_RESOLVER];
						  },
						  _isNestedIframeWithoutSrc: function _isNestedIframeWithoutSrc(win) {
						    if (!win || !win.parent || win.parent === win || win.parent.parent === win.parent) return false;
						    var iframeElement = (0, _dom.getFrameElement)(window);
						    return !!iframeElement && (0, _dom.isIframeWithoutSrc)(iframeElement);
						  },
						  init: function init(doc) {
						    this.updateBase(destLocation.get(), doc);
						  },
						  getResolverElement: function getResolverElement(doc) {
						    return _nativeMethods.default.nodeFirstChildGetter.call(this._getResolver(doc).body);
						  },
						  resolve: function resolve(url, doc) {
						    var resolver = this.getResolverElement(doc);
						    var href = null;
						    if (url === null) _nativeMethods.default.removeAttribute.call(resolver, 'href');else {
						      _nativeMethods.default.anchorHrefSetter.call(resolver, url);

						      href = _nativeMethods.default.anchorHrefGetter.call(resolver); // NOTE: It looks like a Chrome bug: in a nested iframe without src (when an iframe is placed into another
						      // iframe) you cannot set a relative link href while the iframe loading is not completed. So, we'll do it with
						      // the parent's urlResolver Safari demonstrates similar behavior, but urlResolver.href has a relative URL value.

						      var needUseParentResolver = url && (!href || href.charAt(0) === '/') && this._isNestedIframeWithoutSrc(doc.defaultView);

						      if (needUseParentResolver) return this.resolve(url, window.parent.document);
						    }
						    return (0, _url.ensureTrailingSlash)(url, href);
						  },
						  updateBase: function updateBase(url, doc) {
						    var resolverDocument = this._getResolver(doc);

						    var baseElement = _nativeMethods.default.elementGetElementsByTagName.call(resolverDocument.head, 'base')[0];

						    url = url || destLocation.get();
						    /*eslint-disable no-restricted-properties*/

						    var parsedUrl = (0, _url.parseUrl)(url);
						    var isRelativeUrl = parsedUrl.protocol !== 'file:' && !parsedUrl.host;
						    var isProtocolRelativeUrl = /^\/\//.test(url) && !!parsedUrl.host;
						    /*eslint-enable no-restricted-properties*/

						    if (isRelativeUrl || isProtocolRelativeUrl) {
						      var destinationLocation = destLocation.get();
						      this.updateBase(destinationLocation, doc);
						      url = this.resolve(url, doc);
						    }

						    _nativeMethods.default.setAttribute.call(baseElement, 'href', url);
						  },
						  getBaseUrl: function getBaseUrl(doc) {
						    var baseElement = _nativeMethods.default.elementGetElementsByTagName.call(this._getResolver(doc).head, 'base')[0];

						    return _nativeMethods.default.getAttribute.call(baseElement, 'href');
						  },
						  changeUrlPart: function changeUrlPart(url, nativePropSetter, value, doc) {
						    var resolver = this.getResolverElement(doc);

						    _nativeMethods.default.anchorHrefSetter.call(resolver, url);

						    nativePropSetter.call(resolver, value);
						    return _nativeMethods.default.anchorHrefGetter.call(resolver);
						  },
						  dispose: function dispose(doc) {
						    doc[DOCUMENT_URL_RESOLVER] = null;
						  }
						};
						exports.default = _default;
						module.exports = exports.default;
					},
					"url.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.getProxyUrl = getProxyUrl;
						exports.getNavigationUrl = getNavigationUrl;
						exports.getCrossDomainIframeProxyUrl = getCrossDomainIframeProxyUrl;
						exports.getPageProxyUrl = getPageProxyUrl;
						exports.getCrossDomainProxyPort = getCrossDomainProxyPort;
						exports.resolveUrlAsDest = resolveUrlAsDest;
						exports.formatUrl = formatUrl;
						exports.parseProxyUrl = parseProxyUrl;
						exports.parseUrl = parseUrl;
						exports.convertToProxyUrl = convertToProxyUrl;
						exports.changeDestUrlPart = changeDestUrlPart;
						exports.isValidWebSocketUrl = isValidWebSocketUrl;
						exports.isSubDomain = isSubDomain;
						exports.isSupportedProtocol = isSupportedProtocol;
						exports.isSpecialPage = isSpecialPage;
						exports.parseResourceType = parseResourceType;
						exports.stringifyResourceType = stringifyResourceType;
						exports.isChangedOnlyHash = isChangedOnlyHash;
						exports.getDestinationUrl = getDestinationUrl;
						exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = void 0;

						var _internalProperties = _interopRequireDefault(require("../../processing/dom/internal-properties"));

						var sharedUrlUtils = _interopRequireWildcard(require("../../utils/url"));

						var destLocation = _interopRequireWildcard(require("./destination-location"));

						var urlResolver = _interopRequireWildcard(require("./url-resolver"));

						var _settings = _interopRequireDefault(require("../settings"));

						var _globalContextInfo = _interopRequireDefault(require("./global-context-info"));

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var HASH_RE = /#[\S\s]*$/;
						var SUPPORTED_WEB_SOCKET_PROTOCOL_RE = /^wss?:/i; // NOTE: The window.location equals 'about:blank' in iframes without src
						// therefore we need to find a window with src to get the proxy settings

						var DEFAULT_PROXY_SETTINGS = function () {
						  /*eslint-disable no-restricted-properties*/
						  var globalCtx = (0, _globalContextInfo.default)();
						  var locationWindow = globalCtx.isInWorker ? {
						    location: parseUrl(self.location.origin),
						    parent: null
						  } : window;
						  var proxyLocation = locationWindow.location;

						  while (!proxyLocation.hostname) {
						    locationWindow = locationWindow.parent;
						    proxyLocation = locationWindow.location;
						  }

						  return {
						    hostname: proxyLocation.hostname,
						    port: proxyLocation.port.toString(),
						    protocol: proxyLocation.protocol
						  };
						  /*eslint-enable no-restricted-properties*/
						}();

						var REQUEST_DESCRIPTOR_VALUES_SEPARATOR = sharedUrlUtils.REQUEST_DESCRIPTOR_VALUES_SEPARATOR;
						exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = REQUEST_DESCRIPTOR_VALUES_SEPARATOR;

						function getProxyUrl(url, opts) {
						  url = sharedUrlUtils.getURLString(url);
						  var resourceType = opts && opts.resourceType;
						  var parsedResourceType = sharedUrlUtils.parseResourceType(resourceType);
						  if (!parsedResourceType.isWebSocket && !isSupportedProtocol(url) && !isSpecialPage(url)) return url; // NOTE: Resolves relative URLs.

						  var resolvedUrl = destLocation.resolveUrl(url, opts && opts.doc);
						  if (parsedResourceType.isWebSocket && !isValidWebSocketUrl(resolvedUrl) || !sharedUrlUtils.isValidUrl(resolvedUrl)) return url;
						  /*eslint-disable no-restricted-properties*/

						  var proxyHostname = opts && opts.proxyHostname || DEFAULT_PROXY_SETTINGS.hostname;
						  var proxyPort = opts && opts.proxyPort || DEFAULT_PROXY_SETTINGS.port;
						  var proxyServerProtocol = opts && opts.proxyProtocol || DEFAULT_PROXY_SETTINGS.protocol;
						  /*eslint-enable no-restricted-properties*/

						  var proxyProtocol = parsedResourceType.isWebSocket ? proxyServerProtocol.replace('http', 'ws') : proxyServerProtocol;

						  var sessionId = opts && opts.sessionId || _settings.default.get().sessionId;

						  var windowId = opts && opts.windowId || _settings.default.get().windowId;

						  var charset = opts && opts.charset;
						  var reqOrigin = opts && opts.reqOrigin;
						  var crossDomainPort = getCrossDomainProxyPort(proxyPort); // NOTE: If the relative URL contains no slash (e.g. 'img123'), the resolver will keep
						  // the original proxy information, so that we can return such URL as is.
						  // TODO: Implement the isProxyURL function.

						  var parsedProxyUrl = sharedUrlUtils.parseProxyUrl(resolvedUrl);
						  /*eslint-disable no-restricted-properties*/

						  var isValidProxyUrl = !!parsedProxyUrl && parsedProxyUrl.proxy.hostname === proxyHostname && (parsedProxyUrl.proxy.port === proxyPort || parsedProxyUrl.proxy.port === crossDomainPort);
						  /*eslint-enable no-restricted-properties*/

						  if (isValidProxyUrl) {
						    if (resourceType && parsedProxyUrl.resourceType === resourceType) return resolvedUrl; // NOTE: Need to change the proxy URL resource type.

						    var destUrl = sharedUrlUtils.formatUrl(parsedProxyUrl.destResourceInfo);
						    return getProxyUrl(destUrl, {
						      proxyProtocol: proxyProtocol,
						      proxyHostname: proxyHostname,
						      proxyPort: proxyPort,
						      sessionId: sessionId,
						      resourceType: resourceType,
						      charset: charset,
						      reqOrigin: reqOrigin
						    });
						  }

						  var parsedUrl = sharedUrlUtils.parseUrl(resolvedUrl);
						  charset = charset || parsedResourceType.isScript && document[_internalProperties.default.documentCharset]; // NOTE: It seems that the relative URL had the leading slash or dots, so that the proxy info path part was
						  // removed by the resolver and we have an origin URL with the incorrect host and protocol.

						  /*eslint-disable no-restricted-properties*/

						  if (parsedUrl.protocol === proxyServerProtocol && parsedUrl.hostname === proxyHostname && parsedUrl.port === proxyPort) {
						    var parsedDestLocation = destLocation.getParsed();
						    parsedUrl.protocol = parsedDestLocation.protocol;
						    parsedUrl.host = parsedDestLocation.host;
						    parsedUrl.hostname = parsedDestLocation.hostname;
						    parsedUrl.port = parsedDestLocation.port || '';
						    resolvedUrl = sharedUrlUtils.formatUrl(parsedUrl);
						  }
						  /*eslint-enable no-restricted-properties*/


						  if (parsedResourceType.isWebSocket) {
						    // eslint-disable-next-line no-restricted-properties
						    parsedUrl.protocol = parsedUrl.protocol.replace('ws', 'http');
						    resolvedUrl = sharedUrlUtils.formatUrl(parsedUrl);
						    reqOrigin = reqOrigin || encodeURIComponent(destLocation.getOriginHeader());
						  }

						  return sharedUrlUtils.getProxyUrl(resolvedUrl, {
						    proxyProtocol: proxyProtocol,
						    proxyHostname: proxyHostname,
						    proxyPort: proxyPort,
						    sessionId: sessionId,
						    resourceType: resourceType,
						    charset: charset,
						    reqOrigin: reqOrigin,
						    windowId: windowId
						  });
						}

						function getNavigationUrl(url, win) {
						  // NOTE: For the 'about:blank' page, we perform url proxing only for the top window, 'location' object and links.
						  // For images and iframes, we keep urls as they were.
						  // See details in https://github.com/DevExpress/testcafe-hammerhead/issues/339
						  var destinationLocation = null;
						  var isIframe = win.top !== win;
						  var winLocation = win.location.toString();
						  if (isIframe) destinationLocation = winLocation;else {
						    var parsedProxyUrl = parseProxyUrl(winLocation);
						    destinationLocation = parsedProxyUrl && parsedProxyUrl.destUrl;
						  }
						  if (isSpecialPage(destinationLocation) && sharedUrlUtils.isRelativeUrl(url)) return '';
						  url = sharedUrlUtils.prepareUrl(url);
						  return getProxyUrl(url);
						}

						function getCrossDomainIframeProxyUrl(url) {
						  return getProxyUrl(url, {
						    proxyPort: _settings.default.get().crossDomainProxyPort,
						    resourceType: sharedUrlUtils.getResourceTypeString({
						      isIframe: true
						    })
						  });
						}

						function getPageProxyUrl(url, windowId) {
						  var parsedProxyUrl = parseProxyUrl(url);
						  var resourceType = null;

						  if (parsedProxyUrl) {
						    url = parsedProxyUrl.destUrl;
						    resourceType = parsedProxyUrl.resourceType;
						  }

						  if (resourceType) {
						    var parsedResourceType = parseResourceType(resourceType);
						    parsedResourceType.isIframe = false;
						    resourceType = stringifyResourceType(parsedResourceType);
						  }

						  var isCrossDomainUrl = !destLocation.sameOriginCheck(destLocation.getLocation(), url);
						  var proxyPort = isCrossDomainUrl ? _settings.default.get().crossDomainProxyPort : location.port.toString(); // eslint-disable-line no-restricted-properties

						  return getProxyUrl(url, {
						    windowId: windowId,
						    proxyPort: proxyPort,
						    resourceType: resourceType
						  });
						}

						function getCrossDomainProxyPort(proxyPort) {
						  return _settings.default.get().crossDomainProxyPort === proxyPort // eslint-disable-next-line no-restricted-properties
						  ? location.port.toString() : _settings.default.get().crossDomainProxyPort;
						}

						function resolveUrlAsDest(url) {
						  return sharedUrlUtils.resolveUrlAsDest(url, getProxyUrl);
						}

						function formatUrl(parsedUrl) {
						  return sharedUrlUtils.formatUrl(parsedUrl);
						}

						function parseProxyUrl(proxyUrl) {
						  return sharedUrlUtils.parseProxyUrl(proxyUrl);
						}

						function parseUrl(url) {
						  return sharedUrlUtils.parseUrl(url);
						}

						function convertToProxyUrl(url, resourceType, charset) {
						  return getProxyUrl(url, {
						    resourceType: resourceType,
						    charset: charset
						  });
						}

						function changeDestUrlPart(proxyUrl, nativePropSetter, value, resourceType) {
						  var parsed = sharedUrlUtils.parseProxyUrl(proxyUrl);

						  if (parsed) {
						    var sessionId = parsed.sessionId;
						    var proxy = parsed.proxy; // @ts-ignore

						    var destUrl = urlResolver.changeUrlPart(parsed.destUrl, nativePropSetter, value, document);
						    return getProxyUrl(destUrl, {
						      /*eslint-disable no-restricted-properties*/
						      proxyHostname: proxy.hostname,
						      proxyPort: proxy.port,

						      /*eslint-enable no-restricted-properties*/
						      sessionId: sessionId,
						      resourceType: resourceType
						    });
						  }

						  return proxyUrl;
						}

						function isValidWebSocketUrl(url) {
						  var resolvedUrl = resolveUrlAsDest(url);
						  return SUPPORTED_WEB_SOCKET_PROTOCOL_RE.test(resolvedUrl);
						}

						function isSubDomain(domain, subDomain) {
						  return sharedUrlUtils.isSubDomain(domain, subDomain);
						}

						function isSupportedProtocol(url) {
						  return sharedUrlUtils.isSupportedProtocol(url);
						}

						function isSpecialPage(url) {
						  return sharedUrlUtils.isSpecialPage(url);
						}

						function parseResourceType(resourceType) {
						  return sharedUrlUtils.parseResourceType(resourceType);
						}

						function stringifyResourceType(resourceType) {
						  return sharedUrlUtils.getResourceTypeString(resourceType);
						}

						function isChangedOnlyHash(currentUrl, newUrl) {
						  // NOTE: we compare proxied urls because urls passed into the function may be proxied, non-proxied
						  // or relative. The getProxyUrl function solves all the corresponding problems.
						  return getProxyUrl(currentUrl).replace(HASH_RE, '') === getProxyUrl(newUrl).replace(HASH_RE, '');
						}

						function getDestinationUrl(proxyUrl) {
						  var parsedProxyUrl = parseProxyUrl(proxyUrl);
						  return parsedProxyUrl ? parsedProxyUrl.destUrl : proxyUrl;
						}
					}
				},
				"worker": {
					"index.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;

						var sharedUrlUtils = _interopRequireWildcard(require("../../utils/url"));

						var _xhr = _interopRequireDefault(require("../sandbox/xhr"));

						var _fetch = _interopRequireDefault(require("../sandbox/fetch"));

						var _settings = _interopRequireDefault(require("../settings"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

						var WorkerHammerhead = function WorkerHammerhead() {
						  var parsedLocation = sharedUrlUtils.parseProxyUrl(location.toString());

						  var currentSettings = _settings.default.get();

						  var cookieSandboxMock = {
						    syncCookie: function syncCookie() {}
						  };
						  currentSettings.sessionId = parsedLocation && parsedLocation.sessionId;
						  currentSettings.windowId = parsedLocation && parsedLocation.windowId;

						  _settings.default.set(currentSettings);

						  this.fetch = new _fetch.default(cookieSandboxMock);
						  this.fetch.attach(self); // @ts-ignore

						  if (self.XMLHttpRequest) {
						    this.xhr = new _xhr.default(cookieSandboxMock);
						    this.xhr.attach(self);
						  }
						};

						var _default = new WorkerHammerhead();

						exports.default = _default;
						module.exports = exports.default;
					}
				}
			},
			"processing": {
				"dom": {
					"internal-attributes.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;
						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------
						var _default = {
						  storedAttrPostfix: '-hammerhead-stored-value',
						  hoverPseudoClass: 'data-hammerhead-hovered',
						  focusPseudoClass: 'data-hammerhead-focused',
						  uploadInfoHiddenInputName: 'hammerhead|upload-info-hidden-input-name'
						};
						exports.default = _default;
						module.exports = exports.default;
					},
					"internal-properties.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;
						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------
						var _default = {
						  processDomMethodName: 'hammerhead|process-dom-method',
						  processedContext: 'hammerhead|processed-context',
						  documentWasCleaned: 'hammerhead|document-was-cleaned',
						  documentCharset: 'hammerhead|document-charset',
						  iframeNativeMethods: 'hammerhead|iframe-native-methods',
						  hammerhead: '%hammerhead%',
						  selection: 'hammerhead|selection',
						  shadowUIElement: 'hammerhead|shadow-ui-element',
						  forceProxySrcForImage: 'hammerhead|image|force-proxy-src-flag',
						  skipNextLoadEventForImage: 'hammerhead|image|skip-next-load-event-flag',
						  cachedImage: 'hammerhead|image|cached-image',
						  sandboxIsReattached: 'hammerhead|sandbox-is-reattached'
						};
						exports.default = _default;
						module.exports = exports.default;
					}
				}
			},
			"request-pipeline": {
				"builtin-header-names.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.default = void 0;
					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					/* eslint hammerhead/proto-methods: 2 */
					var _default = {
					  authorization: 'authorization',
					  wwwAuthenticate: 'www-authenticate',
					  proxyAuthorization: 'proxy-authorization',
					  proxyAuthenticate: 'proxy-authenticate',
					  host: 'host',
					  referer: 'referer',
					  origin: 'origin',
					  contentLength: 'content-length',
					  cookie: 'cookie',
					  setCookie: 'set-cookie',
					  ifModifiedSince: 'if-modified-since',
					  ifNoneMatch: 'if-none-match',
					  contentType: 'content-type',
					  location: 'location',
					  xFrameOptions: 'x-frame-options',
					  sourceMap: 'sourcemap',
					  referrerPolicy: 'referrer-policy',
					  refresh: 'refresh',
					  link: 'link',
					  cacheControl: 'cache-control',
					  pragma: 'pragma',
					  eTag: 'etag',
					  contentDisposition: 'content-disposition',
					  accept: 'accept',
					  contentEncoding: 'content-encoding',
					  expires: 'expires',
					  accessControlAllowOrigin: 'access-control-allow-origin',
					  accessControlAllowCredentials: 'access-control-allow-credentials',
					  contentSecurityPolicy: 'content-security-policy',
					  contentSecurityPolicyReportOnly: 'content-security-policy-report-only',
					  xContentSecurityPolicy: 'x-content-security-policy',
					  xContentSecurityPolicyReportOnly: 'x-content-security-policy-report-only',
					  xWebkitCsp: 'x-webkit-csp'
					};
					exports.default = _default;
					module.exports = exports.default;
				},
				"internal-header-names.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.default = void 0;

					var _builtinHeaderNames = _interopRequireDefault(require("./builtin-header-names"));

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					/* eslint hammerhead/proto-methods: 2 */
					var hammerheadPrefix = 'x-hammerhead-';
					var _default = {
					  credentials: hammerheadPrefix + 'credentials',
					  origin: hammerheadPrefix + _builtinHeaderNames.default.origin,
					  wwwAuthenticate: hammerheadPrefix + _builtinHeaderNames.default.wwwAuthenticate,
					  proxyAuthenticate: hammerheadPrefix + _builtinHeaderNames.default.proxyAuthenticate,
					  authorization: hammerheadPrefix + _builtinHeaderNames.default.authorization,
					  proxyAuthorization: hammerheadPrefix + _builtinHeaderNames.default.proxyAuthorization
					};
					exports.default = _default;
					module.exports = exports.default;
				},
				"xhr": {
					"same-origin-check-failed-status-code.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = void 0;
						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						/* eslint hammerhead/proto-methods: 2 */
						var SAME_ORIGIN_CHECK_FAILED_STATUS_CODE = 222;
						var _default = SAME_ORIGIN_CHECK_FAILED_STATUS_CODE;
						exports.default = _default;
						module.exports = exports.default;
					}
				}
			},
			"shadow-ui": {
				"class-name.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.default = void 0;
					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					/* eslint hammerhead/proto-methods: 2 */
					var POSTFIX = '-hammerhead-shadow-ui';
					var _default = {
					  postfix: POSTFIX,
					  charset: 'charset' + POSTFIX,
					  script: 'script' + POSTFIX,
					  selfRemovingScript: 'self-removing-script' + POSTFIX,
					  uiStylesheet: 'ui-stylesheet' + POSTFIX
					};
					exports.default = _default;
					module.exports = exports.default;
				}
			},
			"utils": {
				"string-trim.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.default = _default;

					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------
					// NOTE: Some websites override the String.prototype.trim method. When we use this function
					// in our scripts, we expect it to have the default behavior. Therefore, in order to protect
					// ourselves from spoofing, we must use our own implementation. Also, we cannot use the
					// String.prototype.trim method because on the client-side it is the same in the top window and
					// an iframe window. The client code may override this method in the top window before the
					// iframe is initialized, so that the iframe will lose access to the native method.
					function _default(str) {
					  return typeof str === 'string' ? str.replace(/(^\s+)|(\s+$)/g, '') : str;
					}

					module.exports = exports.default;
				},
				"url.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.parseResourceType = parseResourceType;
					exports.getResourceTypeString = getResourceTypeString;
					exports.isSubDomain = isSubDomain;
					exports.sameOriginCheck = sameOriginCheck;
					exports.getURLString = getURLString;
					exports.getProxyUrl = getProxyUrl;
					exports.getDomain = getDomain;
					exports.parseProxyUrl = parseProxyUrl;
					exports.getPathname = getPathname;
					exports.parseUrl = parseUrl;
					exports.isSupportedProtocol = isSupportedProtocol;
					exports.resolveUrlAsDest = resolveUrlAsDest;
					exports.formatUrl = formatUrl;
					exports.correctMultipleSlashes = correctMultipleSlashes;
					exports.processSpecialChars = processSpecialChars;
					exports.ensureTrailingSlash = ensureTrailingSlash;
					exports.isSpecialPage = isSpecialPage;
					exports.isRelativeUrl = isRelativeUrl;
					exports.isValidUrl = isValidUrl;
					exports.ensureOriginTrailingSlash = ensureOriginTrailingSlash;
					exports.omitDefaultPort = omitDefaultPort;
					exports.prepareUrl = prepareUrl;
					exports.updateScriptImportUrls = updateScriptImportUrls;
					exports.HTTPS_DEFAULT_PORT = exports.HTTP_DEFAULT_PORT = exports.SPECIAL_PAGES = exports.SPECIAL_ERROR_PAGE = exports.SPECIAL_BLANK_PAGE = exports.TRAILING_SLASH_RE = exports.REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR = exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = exports.HASH_RE = exports.SUPPORTED_PROTOCOL_RE = void 0;

					var _stringTrim = _interopRequireDefault(require("./string-trim"));

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------
					var PROTOCOL_RE = /^([\w-]+?:)(\/\/|[^\\/]|$)/;
					var LEADING_SLASHES_RE = /^(\/\/)/;
					var HOST_RE = /^(.*?)(\/|%|\?|;|#|$)/;
					var PORT_RE = /:([0-9]*)$/;
					var QUERY_AND_HASH_RE = /(\?.+|#[^#]*)$/;
					var PATH_AFTER_HOST_RE = /^\/([^/]+?)\/([\S\s]+)$/;
					var HTTP_RE = /^https?:/;
					var FILE_RE = /^file:/i;
					var SUPPORTED_PROTOCOL_RE = /^(?:https?|file):/i;
					exports.SUPPORTED_PROTOCOL_RE = SUPPORTED_PROTOCOL_RE;
					var HASH_RE = /^#/;
					exports.HASH_RE = HASH_RE;
					var REQUEST_DESCRIPTOR_VALUES_SEPARATOR = '!';
					exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = REQUEST_DESCRIPTOR_VALUES_SEPARATOR;
					var REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR = '*';
					exports.REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR = REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR;
					var TRAILING_SLASH_RE = /\/$/;
					exports.TRAILING_SLASH_RE = TRAILING_SLASH_RE;
					var SPECIAL_BLANK_PAGE = 'about:blank';
					exports.SPECIAL_BLANK_PAGE = SPECIAL_BLANK_PAGE;
					var SPECIAL_ERROR_PAGE = 'about:error';
					exports.SPECIAL_ERROR_PAGE = SPECIAL_ERROR_PAGE;
					var SPECIAL_PAGES = [SPECIAL_BLANK_PAGE, SPECIAL_ERROR_PAGE];
					exports.SPECIAL_PAGES = SPECIAL_PAGES;
					var HTTP_DEFAULT_PORT = '80';
					exports.HTTP_DEFAULT_PORT = HTTP_DEFAULT_PORT;
					var HTTPS_DEFAULT_PORT = '443';
					exports.HTTPS_DEFAULT_PORT = HTTPS_DEFAULT_PORT;
					var SPECIAL_PAGE_DEST_RESOURCE_INFO = {
					  protocol: 'about:',
					  host: '',
					  hostname: '',
					  port: '',
					  partAfterHost: ''
					};

					function parseResourceType(resourceType) {
					  if (!resourceType) {
					    return {
					      isIframe: false,
					      isForm: false,
					      isScript: false,
					      isEventSource: false,
					      isHtmlImport: false,
					      isWebSocket: false
					    };
					  }

					  return {
					    isIframe: /i/.test(resourceType),
					    isForm: /f/.test(resourceType),
					    isScript: /s/.test(resourceType),
					    isEventSource: /e/.test(resourceType),
					    isHtmlImport: /h/.test(resourceType),
					    isWebSocket: /w/.test(resourceType)
					  };
					}

					function getResourceTypeString(resourceType) {
					  if (!resourceType) return null;
					  if (!resourceType.isIframe && !resourceType.isForm && !resourceType.isScript && !resourceType.isEventSource && !resourceType.isHtmlImport && !resourceType.isWebSocket) return null;
					  return [resourceType.isIframe ? 'i' : '', resourceType.isForm ? 'f' : '', resourceType.isScript ? 's' : '', resourceType.isEventSource ? 'e' : '', resourceType.isHtmlImport ? 'h' : '', resourceType.isWebSocket ? 'w' : ''].join('');
					}

					function isSubDomain(domain, subDomain) {
					  domain = domain.replace(/^www./i, '');
					  subDomain = subDomain.replace(/^www./i, '');
					  if (domain === subDomain) return true;
					  var index = subDomain.lastIndexOf(domain);
					  return subDomain[index - 1] === '.' && subDomain.length === index + domain.length;
					}

					function sameOriginCheck(location, checkedUrl) {
					  if (!checkedUrl) return true;
					  var parsedLocation = parseUrl(location);
					  var parsedCheckedUrl = parseUrl(checkedUrl);
					  var parsedProxyLocation = parseProxyUrl(location);
					  var parsedDestUrl = parsedProxyLocation ? parsedProxyLocation.destResourceInfo : parsedLocation;
					  var isRelative = !parsedCheckedUrl.host;
					  if (isRelative || parsedCheckedUrl.host === parsedLocation.host && parsedCheckedUrl.protocol === parsedLocation.protocol) return true;

					  if (parsedDestUrl) {
					    var portsEq = !parsedDestUrl.port && !parsedCheckedUrl.port || parsedDestUrl.port && parsedDestUrl.port.toString() === parsedCheckedUrl.port;
					    return parsedDestUrl.protocol === parsedCheckedUrl.protocol && !!portsEq && parsedDestUrl.hostname === parsedCheckedUrl.hostname;
					  }

					  return false;
					} // NOTE: Convert the destination protocol and hostname to the lower case. (GH-1)


					function convertHostToLowerCase(url) {
					  var parsedUrl = parseUrl(url);
					  parsedUrl.protocol = parsedUrl.protocol && parsedUrl.protocol.toLowerCase();
					  parsedUrl.host = parsedUrl.host && parsedUrl.host.toLowerCase();
					  return formatUrl(parsedUrl);
					}

					function getURLString(url) {
					  // TODO: fix it
					  // eslint-disable-next-line no-undef
					  if (url === null && /iPad|iPhone/i.test(window.navigator.userAgent)) return '';
					  return String(url).replace(/\n|\t/g, '');
					}

					function getProxyUrl(url, opts) {
					  var sessionInfo = [opts.sessionId];
					  if (opts.windowId) sessionInfo.push(opts.windowId);
					  var params = [sessionInfo.join(REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR)];
					  if (opts.resourceType) params.push(opts.resourceType);
					  if (opts.charset) params.push(opts.charset.toLowerCase());
					  if (opts.reqOrigin) params.push(opts.reqOrigin);
					  var descriptor = params.join(REQUEST_DESCRIPTOR_VALUES_SEPARATOR);
					  var proxyProtocol = opts.proxyProtocol || 'http:';
					  return proxyProtocol + "//" + opts.proxyHostname + ":" + opts.proxyPort + "/" + descriptor + "/" + convertHostToLowerCase(url);
					}

					function getDomain(parsed) {
					  return formatUrl({
					    protocol: parsed.protocol,
					    host: parsed.host,
					    hostname: parsed.hostname,
					    port: parsed.port
					  });
					}

					function parseRequestDescriptor(desc) {
					  var params = desc.split(REQUEST_DESCRIPTOR_VALUES_SEPARATOR);
					  if (!params.length) return null;
					  var sessionInfo = params[0].split(REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR);
					  var sessionId = sessionInfo[0];
					  var resourceType = params[1] || null;
					  var resourceData = params[2] || null;
					  var parsedDesc = {
					    sessionId: sessionId,
					    resourceType: resourceType
					  };
					  if (sessionInfo[1]) parsedDesc.windowId = sessionInfo[1];

					  if (resourceType && resourceData) {
					    var parsedResourceType = parseResourceType(resourceType);
					    if (parsedResourceType.isScript) parsedDesc.charset = resourceData;else if (parsedResourceType.isWebSocket) parsedDesc.reqOrigin = decodeURIComponent(resourceData);
					  }

					  return parsedDesc;
					}

					function parseProxyUrl(proxyUrl) {
					  // TODO: Remove it.
					  var parsedUrl = parseUrl(proxyUrl);
					  if (!parsedUrl.partAfterHost) return null;
					  var match = parsedUrl.partAfterHost.match(PATH_AFTER_HOST_RE);
					  if (!match) return null;
					  var parsedDesc = parseRequestDescriptor(match[1]); // NOTE: We should have, at least, the job uid and the owner token.

					  if (!parsedDesc) return null;
					  var destUrl = match[2]; // Browser can redirect to a special page with hash (GH-1671)

					  var destUrlWithoutHash = destUrl.replace(/#[\S\s]*$/, '');
					  if (!isSpecialPage(destUrlWithoutHash) && !SUPPORTED_PROTOCOL_RE.test(destUrl)) return null;
					  var destResourceInfo = null;
					  if (isSpecialPage(destUrlWithoutHash)) destResourceInfo = SPECIAL_PAGE_DEST_RESOURCE_INFO;else {
					    destUrl = omitDefaultPort(destUrl);
					    destResourceInfo = parseUrl(destUrl);
					  }
					  return {
					    destUrl: destUrl,
					    destResourceInfo: destResourceInfo,
					    partAfterHost: parsedUrl.partAfterHost,
					    proxy: {
					      hostname: parsedUrl.hostname,
					      port: parsedUrl.port
					    },
					    sessionId: parsedDesc.sessionId,
					    resourceType: parsedDesc.resourceType,
					    charset: parsedDesc.charset,
					    reqOrigin: parsedDesc.reqOrigin,
					    windowId: parsedDesc.windowId
					  };
					}

					function getPathname(path) {
					  return path.replace(QUERY_AND_HASH_RE, '');
					}

					function parseUrl(url) {
					  var parsed = {};
					  url = processSpecialChars(url);
					  if (!url) return parsed;
					  url = (0, _stringTrim.default)(url); // Protocol

					  var hasImplicitProtocol = false;
					  var remainder = url.replace(PROTOCOL_RE, function (_str, protocol, strAfterProtocol) {
					    parsed.protocol = protocol;
					    return strAfterProtocol;
					  }).replace(LEADING_SLASHES_RE, function () {
					    hasImplicitProtocol = true;
					    return '';
					  }); // NOTE: the URL is relative.

					  if (!parsed.protocol && !hasImplicitProtocol) {
					    parsed.partAfterHost = url;
					    return parsed;
					  } // Host


					  parsed.partAfterHost = remainder.replace(HOST_RE, function (_str, host, restPartSeparator) {
					    parsed.host = host;
					    parsed.port = '';
					    return restPartSeparator;
					  });

					  if (typeof parsed.host === 'string') {
					    var authHostArr = parsed.host.split('@');

					    if (authHostArr.length === 2) {
					      parsed.auth = authHostArr[0];
					      parsed.host = authHostArr[1];
					    }
					  }

					  parsed.hostname = parsed.host ? parsed.host.replace(PORT_RE, function (_str, port) {
					    parsed.port = port;
					    return '';
					  }) : '';
					  return parsed;
					}

					function isSupportedProtocol(url) {
					  url = (0, _stringTrim.default)(url || '');
					  var isHash = HASH_RE.test(url);
					  if (isHash) return false;
					  var protocol = url.match(PROTOCOL_RE);
					  if (!protocol) return true;
					  return SUPPORTED_PROTOCOL_RE.test(protocol[0]);
					}

					function resolveUrlAsDest(url, getProxyUrlMeth) {
					  getProxyUrlMeth = getProxyUrlMeth || getProxyUrl;

					  if (isSupportedProtocol(url)) {
					    var proxyUrl = getProxyUrlMeth(url);
					    var parsedProxyUrl = parseProxyUrl(proxyUrl);
					    return parsedProxyUrl ? formatUrl(parsedProxyUrl.destResourceInfo) : url;
					  }

					  return url;
					}

					function formatUrl(parsedUrl) {
					  // NOTE: the URL is relative.
					  if (parsedUrl.protocol !== 'file:' && !parsedUrl.host && (!parsedUrl.hostname || !parsedUrl.port)) return parsedUrl.partAfterHost;
					  var url = parsedUrl.protocol || '';
					  if (parsedUrl.protocol !== 'about:') url += '//';
					  if (parsedUrl.auth) url += parsedUrl.auth + '@';
					  if (parsedUrl.host) url += parsedUrl.host;else {
					    url += parsedUrl.hostname;
					    if (parsedUrl.port) url += ':' + parsedUrl.port;
					  }
					  if (parsedUrl.partAfterHost) url += parsedUrl.partAfterHost;
					  return url;
					}

					function correctMultipleSlashes(url, pageProtocol) {
					  if (pageProtocol === void 0) {
					    pageProtocol = '';
					  }

					  // NOTE: Remove unnecessary slashes from the beginning of the url and after scheme.
					  // For example:
					  // "//////example.com" -> "//example.com" (scheme-less HTTP(S) URL)
					  // "////home/testcafe/documents" -> "///home/testcafe/documents" (scheme-less unix file URL)
					  // "http:///example.com" -> "http://example.com"
					  //
					  // And add missing slashes after the file scheme.
					  // "file://C:/document.txt" -> "file:///C:/document.txt"
					  if (url.match(FILE_RE) || pageProtocol.match(FILE_RE)) {
					    return url.replace(/^(file:)?\/+(\/\/\/.*$)/i, '$1$2').replace(/^(file:)?\/*([A-Za-z]):/i, '$1///$2:');
					  }

					  return url.replace(/^(https?:)?\/+(\/\/.*$)/i, '$1$2');
					}

					function processSpecialChars(url) {
					  return correctMultipleSlashes(getURLString(url));
					}

					function ensureTrailingSlash(srcUrl, processedUrl) {
					  if (!isValidUrl(processedUrl)) return processedUrl;
					  var srcUrlEndsWithTrailingSlash = TRAILING_SLASH_RE.test(srcUrl);
					  var processedUrlEndsWithTrailingSlash = TRAILING_SLASH_RE.test(processedUrl);
					  if (srcUrlEndsWithTrailingSlash && !processedUrlEndsWithTrailingSlash) processedUrl += '/';else if (srcUrl && !srcUrlEndsWithTrailingSlash && processedUrlEndsWithTrailingSlash) processedUrl = processedUrl.replace(TRAILING_SLASH_RE, '');
					  return processedUrl;
					}

					function isSpecialPage(url) {
					  return SPECIAL_PAGES.indexOf(url) !== -1;
					}

					function isRelativeUrl(url) {
					  var parsedUrl = parseUrl(url);
					  return parsedUrl.protocol !== 'file:' && !parsedUrl.host;
					}

					function isValidPort(port) {
					  var parsedPort = parseInt(port, 10);
					  return parsedPort > 0 && parsedPort <= 65535;
					}

					function isValidUrl(url) {
					  var parsedUrl = parseUrl(url);
					  return parsedUrl.protocol === 'file:' || !!parsedUrl.hostname && (!parsedUrl.port || isValidPort(parsedUrl.port));
					}

					function ensureOriginTrailingSlash(url) {
					  // NOTE: If you request an url containing only port, host and protocol
					  // then browser adds the trailing slash itself.
					  var parsedUrl = parseUrl(url);
					  if (!parsedUrl.partAfterHost && HTTP_RE.test(parsedUrl.protocol)) return url + '/';
					  return url;
					}

					function omitDefaultPort(url) {
					  // NOTE: If you request an url containing default port
					  // then browser remove this one itself.
					  var parsedUrl = parseUrl(url);
					  var hasDefaultPort = parsedUrl.protocol === 'https:' && parsedUrl.port === HTTPS_DEFAULT_PORT || parsedUrl.protocol === 'http:' && parsedUrl.port === HTTP_DEFAULT_PORT;

					  if (hasDefaultPort) {
					    parsedUrl.host = parsedUrl.hostname;
					    parsedUrl.port = '';
					    return formatUrl(parsedUrl);
					  }

					  return url;
					}

					function prepareUrl(url) {
					  url = omitDefaultPort(url);
					  url = ensureOriginTrailingSlash(url);
					  return url;
					}

					function updateScriptImportUrls(cachedScript, serverInfo, sessionId, windowId) {
					  var regExp = new RegExp('(' + serverInfo.protocol + '//' + serverInfo.hostname + ':(?:' + serverInfo.port + '|' + serverInfo.crossDomainPort + ')/)[^/' + REQUEST_DESCRIPTOR_VALUES_SEPARATOR + ']+', 'g');
					  var pattern = '$1' + sessionId + (windowId ? REQUEST_DESCRIPTOR_SESSION_INFO_VALUES_SEPARATOR + windowId : '');
					  return cachedScript.replace(regExp, pattern);
					}
				}
			}
		}
	}
})("testcafe-hammerhead/src/client/worker/index");
