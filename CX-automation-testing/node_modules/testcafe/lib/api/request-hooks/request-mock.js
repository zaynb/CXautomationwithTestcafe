"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hook_1 = __importDefault(require("./hook"));
const testcafe_hammerhead_1 = require("testcafe-hammerhead");
const runtime_1 = require("../../errors/runtime");
const types_1 = require("../../errors/types");
const warning_message_1 = __importDefault(require("../../notifications/warning-message"));
class RequestMock extends hook_1.default {
    constructor() {
        super([]);
        this._pendingRequestFilterRuleInit = null;
        this._mocks = new Map();
    }
    async onRequest(event) {
        const mock = this._mocks.get(event._requestFilterRule);
        event.setMock(mock);
    }
    async onResponse(event) {
        if (event.statusCode === testcafe_hammerhead_1.SAME_ORIGIN_CHECK_FAILED_STATUS_CODE)
            this.warningLog.addWarning(warning_message_1.default.requestMockCORSValidationFailed, RequestMock.name, event._requestFilterRule);
    }
    // API
    onRequestTo(requestFilterRuleInit) {
        if (this._pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('onRequestTo', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'respond' method was not called after 'onRequestTo'. You must call the 'respond' method to provide the mocked response.");
        this._pendingRequestFilterRuleInit = requestFilterRuleInit;
        return this;
    }
    respond(body, statusCode, headers) {
        if (!this._pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('respond', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'onRequestTo' method was not called before 'respond'. You must call the 'onRequestTo' method to provide the URL requests to which are mocked.");
        const mock = new testcafe_hammerhead_1.ResponseMock(body, statusCode, headers);
        const rule = new testcafe_hammerhead_1.RequestFilterRule(this._pendingRequestFilterRuleInit);
        this.requestFilterRules.push(rule);
        this._mocks.set(rule, mock);
        this._pendingRequestFilterRuleInit = null;
        return this;
    }
}
function createRequestMock() {
    return new RequestMock();
}
exports.default = createRequestMock;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWVzdC1tb2NrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS9yZXF1ZXN0LWhvb2tzL3JlcXVlc3QtbW9jay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtEQUFpQztBQUVqQyw2REFNNkI7QUFFN0Isa0RBQWdEO0FBQ2hELDhDQUFvRDtBQUNwRCwwRkFBa0U7QUFLbEUsTUFBTSxXQUFZLFNBQVEsY0FBVztJQUlqQztRQUNJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVWLElBQUksQ0FBQyw2QkFBNkIsR0FBRyxJQUFJLENBQUM7UUFDMUMsSUFBSSxDQUFDLE1BQU0sR0FBMEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBRU0sS0FBSyxDQUFDLFNBQVMsQ0FBRSxLQUFtQjtRQUN2QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQWlCLENBQUM7UUFFdkUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRU0sS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFvQjtRQUN6QyxJQUFJLEtBQUssQ0FBQyxVQUFVLEtBQUssMERBQW9DO1lBQ3hELElBQUksQ0FBQyxVQUF5QixDQUFDLFVBQVUsQ0FBQyx5QkFBZSxDQUFDLCtCQUErQixFQUFFLFdBQVcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDaEosQ0FBQztJQUVELE1BQU07SUFDQyxXQUFXLENBQUUscUJBQTRDO1FBQzVELElBQUksSUFBSSxDQUFDLDZCQUE2QjtZQUNsQyxNQUFNLElBQUksa0JBQVEsQ0FBQyxhQUFhLEVBQUUsc0JBQWMsQ0FBQyw0QkFBNEIsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFLDZIQUE2SCxDQUFDLENBQUM7UUFFcE8sSUFBSSxDQUFDLDZCQUE2QixHQUFHLHFCQUFxQixDQUFDO1FBRTNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxPQUFPLENBQUUsSUFBdUIsRUFBRSxVQUFtQixFQUFFLE9BQWdCO1FBQzFFLElBQUksQ0FBQyxJQUFJLENBQUMsNkJBQTZCO1lBQ25DLE1BQU0sSUFBSSxrQkFBUSxDQUFDLFNBQVMsRUFBRSxzQkFBYyxDQUFDLDRCQUE0QixFQUFFLFdBQVcsQ0FBQyxJQUFJLEVBQUUsbUpBQW1KLENBQUMsQ0FBQztRQUV0UCxNQUFNLElBQUksR0FBRyxJQUFJLGtDQUFZLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN6RCxNQUFNLElBQUksR0FBRyxJQUFJLHVDQUFpQixDQUFDLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBRXZFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyw2QkFBNkIsR0FBRyxJQUFJLENBQUM7UUFFMUMsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztDQUNKO0FBRUQsU0FBd0IsaUJBQWlCO0lBQ3JDLE9BQU8sSUFBSSxXQUFXLEVBQUUsQ0FBQztBQUM3QixDQUFDO0FBRkQsb0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVxdWVzdEhvb2sgZnJvbSAnLi9ob29rJztcblxuaW1wb3J0IHtcbiAgICBSZXNwb25zZU1vY2ssXG4gICAgUmVxdWVzdEV2ZW50LFxuICAgIFJlc3BvbnNlRXZlbnQsXG4gICAgUmVxdWVzdEZpbHRlclJ1bGUsXG4gICAgU0FNRV9PUklHSU5fQ0hFQ0tfRkFJTEVEX1NUQVRVU19DT0RFXG59IGZyb20gJ3Rlc3RjYWZlLWhhbW1lcmhlYWQnO1xuXG5pbXBvcnQgeyBBUElFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCB7IFJVTlRJTUVfRVJST1JTIH0gZnJvbSAnLi4vLi4vZXJyb3JzL3R5cGVzJztcbmltcG9ydCBXQVJOSU5HX01FU1NBR0UgZnJvbSAnLi4vLi4vbm90aWZpY2F0aW9ucy93YXJuaW5nLW1lc3NhZ2UnO1xuaW1wb3J0IFdhcm5pbmdMb2cgZnJvbSAnLi4vLi4vbm90aWZpY2F0aW9ucy93YXJuaW5nLWxvZyc7XG5pbXBvcnQgeyBSZXF1ZXN0RmlsdGVyUnVsZUluaXQgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG5cbmNsYXNzIFJlcXVlc3RNb2NrIGV4dGVuZHMgUmVxdWVzdEhvb2sge1xuICAgIHByaXZhdGUgX3BlbmRpbmdSZXF1ZXN0RmlsdGVyUnVsZUluaXQ6IG51bGwgfCBSZXF1ZXN0RmlsdGVyUnVsZUluaXQ7XG4gICAgcHJpdmF0ZSBfbW9ja3M6IE1hcDxSZXF1ZXN0RmlsdGVyUnVsZSwgUmVzcG9uc2VNb2NrPjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHN1cGVyKFtdKTtcblxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbW9ja3MgICAgICAgICAgICAgICAgICAgICAgICA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgb25SZXF1ZXN0IChldmVudDogUmVxdWVzdEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSB0aGlzLl9tb2Nrcy5nZXQoZXZlbnQuX3JlcXVlc3RGaWx0ZXJSdWxlKSBhcyBSZXNwb25zZU1vY2s7XG5cbiAgICAgICAgZXZlbnQuc2V0TW9jayhtb2NrKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgb25SZXNwb25zZSAoZXZlbnQ6IFJlc3BvbnNlRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKGV2ZW50LnN0YXR1c0NvZGUgPT09IFNBTUVfT1JJR0lOX0NIRUNLX0ZBSUxFRF9TVEFUVVNfQ09ERSlcbiAgICAgICAgICAgICh0aGlzLndhcm5pbmdMb2cgYXMgV2FybmluZ0xvZykuYWRkV2FybmluZyhXQVJOSU5HX01FU1NBR0UucmVxdWVzdE1vY2tDT1JTVmFsaWRhdGlvbkZhaWxlZCwgUmVxdWVzdE1vY2submFtZSwgZXZlbnQuX3JlcXVlc3RGaWx0ZXJSdWxlKTtcbiAgICB9XG5cbiAgICAvLyBBUElcbiAgICBwdWJsaWMgb25SZXF1ZXN0VG8gKHJlcXVlc3RGaWx0ZXJSdWxlSW5pdDogUmVxdWVzdEZpbHRlclJ1bGVJbml0KTogUmVxdWVzdE1vY2sge1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcignb25SZXF1ZXN0VG8nLCBSVU5USU1FX0VSUk9SUy5yZXF1ZXN0SG9va0NvbmZpZ3VyZUFQSUVycm9yLCBSZXF1ZXN0TW9jay5uYW1lLCBcIlRoZSAncmVzcG9uZCcgbWV0aG9kIHdhcyBub3QgY2FsbGVkIGFmdGVyICdvblJlcXVlc3RUbycuIFlvdSBtdXN0IGNhbGwgdGhlICdyZXNwb25kJyBtZXRob2QgdG8gcHJvdmlkZSB0aGUgbW9ja2VkIHJlc3BvbnNlLlwiKTtcblxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0ID0gcmVxdWVzdEZpbHRlclJ1bGVJbml0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyByZXNwb25kIChib2R5OiBzdHJpbmcgfCBGdW5jdGlvbiwgc3RhdHVzQ29kZT86IG51bWJlciwgaGVhZGVycz86IG9iamVjdCk6IFJlcXVlc3RNb2NrIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKCdyZXNwb25kJywgUlVOVElNRV9FUlJPUlMucmVxdWVzdEhvb2tDb25maWd1cmVBUElFcnJvciwgUmVxdWVzdE1vY2submFtZSwgXCJUaGUgJ29uUmVxdWVzdFRvJyBtZXRob2Qgd2FzIG5vdCBjYWxsZWQgYmVmb3JlICdyZXNwb25kJy4gWW91IG11c3QgY2FsbCB0aGUgJ29uUmVxdWVzdFRvJyBtZXRob2QgdG8gcHJvdmlkZSB0aGUgVVJMIHJlcXVlc3RzIHRvIHdoaWNoIGFyZSBtb2NrZWQuXCIpO1xuXG4gICAgICAgIGNvbnN0IG1vY2sgPSBuZXcgUmVzcG9uc2VNb2NrKGJvZHksIHN0YXR1c0NvZGUsIGhlYWRlcnMpO1xuICAgICAgICBjb25zdCBydWxlID0gbmV3IFJlcXVlc3RGaWx0ZXJSdWxlKHRoaXMuX3BlbmRpbmdSZXF1ZXN0RmlsdGVyUnVsZUluaXQpO1xuXG4gICAgICAgIHRoaXMucmVxdWVzdEZpbHRlclJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIHRoaXMuX21vY2tzLnNldChydWxlLCBtb2NrKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0TW9jayAoKTogUmVxdWVzdE1vY2sge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdE1vY2soKTtcbn1cbiJdfQ==