"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const io_1 = require("./io");
const test_structure_1 = require("./test-structure");
const test_run_tracker_1 = __importDefault(require("../../api/test-run-tracker"));
const proxy_1 = require("../utils/ipc/proxy");
const transport_1 = require("../utils/ipc/transport");
const async_event_emitter_1 = __importDefault(require("../../utils/async-event-emitter"));
const error_list_1 = __importDefault(require("../../errors/error-list"));
const SERVICE_PATH = require.resolve('./service');
class CompilerHost extends async_event_emitter_1.default {
    constructor() {
        super();
        this.runtime = Promise.resolve(void 0);
    }
    _setupRoutes(proxy) {
        proxy.register(this.executeAction, this);
        proxy.register(this.ready, this);
    }
    async _init(runtime) {
        const resolvedRuntime = await runtime;
        if (resolvedRuntime)
            return resolvedRuntime;
        try {
            const service = child_process_1.spawn(process.argv0, [SERVICE_PATH], { stdio: [0, 1, 2, 'pipe', 'pipe', 'pipe'] });
            // HACK: Node.js definition are not correct when additional I/O channels are sp
            const stdio = service.stdio;
            const proxy = new proxy_1.IPCProxy(new transport_1.HostTransport(stdio[io_1.HOST_INPUT_FD], stdio[io_1.HOST_OUTPUT_FD], stdio[io_1.HOST_SYNC_FD]));
            this._setupRoutes(proxy);
            await this.once('ready');
            return { proxy, service };
        }
        catch (e) {
            return void 0;
        }
    }
    async _getRuntime() {
        const runtime = await this.runtime;
        if (!runtime)
            throw new Error();
        return runtime;
    }
    async init() {
        this.runtime = this._init(this.runtime);
        await this.runtime;
    }
    async stop() {
        const { service } = await this._getRuntime();
        service.kill();
    }
    _wrapTestFunction(id, functionName) {
        return async (testRun) => {
            try {
                return await this.runTest({ id, functionName, testRunId: testRun.id });
            }
            catch (err) {
                const errList = new error_list_1.default();
                errList.addError(err);
                throw errList;
            }
        };
    }
    async ready() {
        this.emit('ready');
    }
    async executeAction(data) {
        if (!test_run_tracker_1.default.activeTestRuns[data.id])
            return void 0;
        return test_run_tracker_1.default
            .activeTestRuns[data.id]
            .executeAction(data.apiMethodName, data.command, data.callsite);
    }
    async getTests({ sourceList, compilerOptions }) {
        const { proxy } = await this._getRuntime();
        const units = await proxy.call(this.getTests, { sourceList, compilerOptions });
        return test_structure_1.restore(units, (...args) => this._wrapTestFunction(...args));
    }
    async runTest({ id, functionName, testRunId }) {
        const { proxy } = await this._getRuntime();
        return await proxy.call(this.runTest, { id, functionName, testRunId });
    }
    async cleanUp() {
        const { proxy } = await this._getRuntime();
        await proxy.call(this.cleanUp);
    }
}
exports.default = CompilerHost;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG9zdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9jb21waWxlci9ob3N0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaURBQW9EO0FBQ3BELDZCQUljO0FBRWQscURBQW1FO0FBQ25FLGtGQUFnRjtBQUNoRiw4Q0FBOEM7QUFDOUMsc0RBQXVEO0FBQ3ZELDBGQUEyRDtBQUMzRCx5RUFBd0Q7QUFZeEQsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQVdsRCxNQUFxQixZQUFhLFNBQVEsNkJBQVk7SUFHbEQ7UUFDSSxLQUFLLEVBQUUsQ0FBQztRQUVSLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTyxZQUFZLENBQUUsS0FBZTtRQUNqQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDekMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFHTyxLQUFLLENBQUMsS0FBSyxDQUFFLE9BQTRDO1FBQzdELE1BQU0sZUFBZSxHQUFHLE1BQU0sT0FBTyxDQUFDO1FBRXRDLElBQUksZUFBZTtZQUNmLE9BQU8sZUFBZSxDQUFDO1FBRTNCLElBQUk7WUFDQSxNQUFNLE9BQU8sR0FBRyxxQkFBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRW5HLCtFQUErRTtZQUMvRSxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBWSxDQUFD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QUFTLEVBQW9CO1FBQ25FLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUUzQyxPQUFPLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFTSxLQUFLLENBQUMsT0FBTztRQUNoQixNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFM0MsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQyxDQUFDO0NBRUo7QUE5R0QsK0JBOEdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd24sIENoaWxkUHJvY2VzcyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHtcbiAgICBIT1NUX0lOUFVUX0ZELFxuICAgIEhPU1RfT1VUUFVUX0ZELFxuICAgIEhPU1RfU1lOQ19GRFxufSBmcm9tICcuL2lvJztcblxuaW1wb3J0IHsgcmVzdG9yZSBhcyByZXN0b3JlVGVzdFN0cnVjdHVyZSB9IGZyb20gJy4vdGVzdC1zdHJ1Y3R1cmUnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyB0ZXN0UnVuVHJhY2tlciwgVGVzdFJ1biB9IGZyb20gJy4uLy4uL2FwaS90ZXN0LXJ1bi10cmFja2VyJztcbmltcG9ydCB7IElQQ1Byb3h5IH0gZnJvbSAnLi4vdXRpbHMvaXBjL3Byb3h5JztcbmltcG9ydCB7IEhvc3RUcmFuc3BvcnQgfSBmcm9tICcuLi91dGlscy9pcGMvdHJhbnNwb3J0JztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vLi4vdXRpbHMvYXN5bmMtZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgVGVzdENhZmVFcnJvckxpc3QgZnJvbSAnLi4vLi4vZXJyb3JzL2Vycm9yLWxpc3QnO1xuXG5pbXBvcnQge1xuICAgIENvbXBpbGVyUHJvdG9jb2wsXG4gICAgUnVuVGVzdEFyZ3VtZW50cyxcbiAgICBFeGVjdXRlQ29tbWFuZEFyZ3VtZW50cyxcbiAgICBGdW5jdGlvblByb3BlcnRpZXNcbn0gZnJvbSAnLi9wcm90b2NvbCc7XG5cbmltcG9ydCB7IENvbXBpbGVyQXJndW1lbnRzIH0gZnJvbSAnLi4vLi4vY29tcGlsZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgVGVzdCBmcm9tICcuLi8uLi9hcGkvc3RydWN0dXJlL3Rlc3QnO1xuXG5jb25zdCBTRVJWSUNFX1BBVEggPSByZXF1aXJlLnJlc29sdmUoJy4vc2VydmljZScpO1xuXG5pbnRlcmZhY2UgUnVudGltZVJlc291cmNlcyB7XG4gICAgc2VydmljZTogQ2hpbGRQcm9jZXNzO1xuICAgIHByb3h5OiBJUENQcm94eTtcbn1cblxuaW50ZXJmYWNlIFRlc3RGdW5jdGlvbiB7XG4gICAgKHRlc3RSdW46IFRlc3RSdW4pOiBQcm9taXNlPHVua25vd24+O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlckhvc3QgZXh0ZW5kcyBFdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBDb21waWxlclByb3RvY29sIHtcbiAgICBwcml2YXRlIHJ1bnRpbWU6IFByb21pc2U8UnVudGltZVJlc291cmNlc3x1bmRlZmluZWQ+O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZXR1cFJvdXRlcyAocHJveHk6IElQQ1Byb3h5KTogdm9pZCB7XG4gICAgICAgIHByb3h5LnJlZ2lzdGVyKHRoaXMuZXhlY3V0ZUFjdGlvbiwgdGhpcyk7XG4gICAgICAgIHByb3h5LnJlZ2lzdGVyKHRoaXMucmVhZHksIHRoaXMpO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5pdCAocnVudGltZTogUHJvbWlzZTxSdW50aW1lUmVzb3VyY2VzfHVuZGVmaW5lZD4pOiBQcm9taXNlPFJ1bnRpbWVSZXNvdXJjZXN8dW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUnVudGltZSA9IGF3YWl0IHJ1bnRpbWU7XG5cbiAgICAgICAgaWYgKHJlc29sdmVkUnVudGltZSlcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZFJ1bnRpbWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBzcGF3bihwcm9jZXNzLmFyZ3YwLCBbU0VSVklDRV9QQVRIXSwgeyBzdGRpbzogWzAsIDEsIDIsICdwaXBlJywgJ3BpcGUnLCAncGlwZSddIH0pO1xuXG4gICAgICAgICAgICAvLyBIQUNLOiBOb2RlLmpzIGRlZmluaXRpb24gYXJlIG5vdCBjb3JyZWN0IHdoZW4gYWRkaXRpb25hbCBJL08gY2hhbm5lbHMgYXJlIHNwXG4gICAgICAgICAgICBjb25zdCBzdGRpbyA9IHNlcnZpY2Uuc3RkaW8gYXMgYW55O1xuICAgICAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgSVBDUHJveHkobmV3IEhvc3RUcmFuc3BvcnQoc3RkaW9bSE9TVF9JTlBVVF9GRF0sIHN0ZGlvW0hPU1RfT1VUUFVUX0ZEXSwgc3RkaW9bSE9TVF9TWU5DX0ZEXSkpO1xuXG4gICAgICAgICAgICB0aGlzLl9zZXR1cFJvdXRlcyhwcm94eSk7XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMub25jZSgncmVhZHknKTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcHJveHksIHNlcnZpY2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2dldFJ1bnRpbWUgKCk6IFByb21pc2U8UnVudGltZVJlc291cmNlcz4ge1xuICAgICAgICBjb25zdCBydW50aW1lID0gYXdhaXQgdGhpcy5ydW50aW1lO1xuXG4gICAgICAgIGlmICghcnVudGltZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuXG4gICAgICAgIHJldHVybiBydW50aW1lO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBpbml0ICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5ydW50aW1lID0gdGhpcy5faW5pdCh0aGlzLnJ1bnRpbWUpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMucnVudGltZTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBhc3luYyBzdG9wICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBzZXJ2aWNlIH0gPSBhd2FpdCB0aGlzLl9nZXRSdW50aW1lKCk7XG5cbiAgICAgICAgc2VydmljZS5raWxsKCk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIF93cmFwVGVzdEZ1bmN0aW9uIChpZDogc3RyaW5nLCBmdW5jdGlvbk5hbWU6IEZ1bmN0aW9uUHJvcGVydGllcyk6IFRlc3RGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiBhc3luYyB0ZXN0UnVuID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucnVuVGVzdCh7IGlkLCBmdW5jdGlvbk5hbWUsIHRlc3RSdW5JZDogdGVzdFJ1bi5pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJMaXN0ID0gbmV3IFRlc3RDYWZlRXJyb3JMaXN0KCk7XG5cbiAgICAgICAgICAgICAgICBlcnJMaXN0LmFkZEVycm9yKGVycik7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyByZWFkeSAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZXhlY3V0ZUFjdGlvbiAoZGF0YTogRXhlY3V0ZUNvbW1hbmRBcmd1bWVudHMpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICAgICAgaWYgKCF0ZXN0UnVuVHJhY2tlci5hY3RpdmVUZXN0UnVuc1tkYXRhLmlkXSlcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICAgICAgcmV0dXJuIHRlc3RSdW5UcmFja2VyXG4gICAgICAgICAgICAuYWN0aXZlVGVzdFJ1bnNbZGF0YS5pZF1cbiAgICAgICAgICAgIC5leGVjdXRlQWN0aW9uKGRhdGEuYXBpTWV0aG9kTmFtZSwgZGF0YS5jb21tYW5kLCBkYXRhLmNhbGxzaXRlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VGVzdHMgKHsgc291cmNlTGlzdCwgY29tcGlsZXJPcHRpb25zIH06IENvbXBpbGVyQXJndW1lbnRzKTogUHJvbWlzZTxUZXN0W10+IHtcbiAgICAgICAgY29uc3QgeyBwcm94eSB9ID0gYXdhaXQgdGhpcy5fZ2V0UnVudGltZSgpO1xuXG4gICAgICAgIGNvbnN0IHVuaXRzID0gYXdhaXQgcHJveHkuY2FsbCh0aGlzLmdldFRlc3RzLCB7IHNvdXJjZUxpc3QsIGNvbXBpbGVyT3B0aW9ucyB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdG9yZVRlc3RTdHJ1Y3R1cmUodW5pdHMsICguLi5hcmdzKSA9PiB0aGlzLl93cmFwVGVzdEZ1bmN0aW9uKC4uLmFyZ3MpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcnVuVGVzdCAoeyBpZCwgZnVuY3Rpb25OYW1lLCB0ZXN0UnVuSWQgfTogUnVuVGVzdEFyZ3VtZW50cyk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAgICBjb25zdCB7IHByb3h5IH0gPSBhd2FpdCB0aGlzLl9nZXRSdW50aW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3h5LmNhbGwodGhpcy5ydW5UZXN0LCB7IGlkLCBmdW5jdGlvbk5hbWUsIHRlc3RSdW5JZCB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgY2xlYW5VcCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgcHJveHkgfSA9IGF3YWl0IHRoaXMuX2dldFJ1bnRpbWUoKTtcblxuICAgICAgICBhd2FpdCBwcm94eS5jYWxsKHRoaXMuY2xlYW5VcCk7XG4gICAgfVxuXG59XG4iXX0=